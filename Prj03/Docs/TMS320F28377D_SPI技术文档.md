This chapter describes the serial peripheral interface (SPI) which is a high-speed synchronous serial input and output (I/O) port that allows a serial bit stream of programmed length (one to 16 bits) to be shifted into and out of the device at a programmed bit-transfer rate. The SPI is normally used for communications between the MCU controller and external peripherals or another controller. Typical applications include external I/O or peripheral expansion via devices such as shift registers, display drivers, and analog-to-digital converters (ADCs). Multi-device communications are supported by the master or slave operation of the SPI. The port supports a 16-level, receive and transmit FIFO for reducing CPU servicing overhead.

# Topic

# Page

18.1 Introduction 2223  
18.2 System-Level Integration 2224  
18.3 SPI Operation 2227  
18.4 Programming Procedure 2237  
18.5 SPI Registers 2242

# 18.1 Introduction

# 18.1.1 Features

The SPI module features include:

SPISOMI: SPI slave-output/master-input pin  
SPISIMO: SPI slave-input/master-output pin  
SPISTE: SPI slave transmit-enable pin  
SPICLK: SPI serial-clock pin

NOTE: All four pins can be used as GPIO if the SPI module is not used.

- Two operational modes: Master and Slave  
- Baud rate: 125 different programmable rates. The maximum baud rate that can be employed is limited by the maximum speed of the I/O buffers used on the SPI pins. See the device-specific data manual for more details.  
Data word length: one to sixteen data bits  
- Four clocking schemes (controlled by clock polarity and clock phase bits) include:

- Falling edge without phase delay: SPICLK active-high. SPI transmits data on the falling edge of the SPICLK signal and receives data on the rising edge of the SPICLK signal.  
- Falling edge with phase delay: SPICLK active-high. SPI transmits data one half-cycle ahead of the falling edge of the SPICLK signal and receives data on the falling edge of the SPICLK signal.  
- Rising edge without phase delay: SPICLK inactive-low. SPI transmits data on the rising edge of the SPICLK signal and receives data on the falling edge of the SPICLK signal.  
- Rising edge with phase delay: SPICLK inactive-low. SPI transmits data one half-cycle ahead of the rising edge of the SPICLK signal and receives data on the rising edge of the SPICLK signal.

- Simultaneous receive and transmit operation (transmit function can be disabled in software)  
- Transmitter and receiver operations are accomplished through either interrupt- driven or polled algorithm  
16-level transmit/receive FIFO  
DMA support  
High-speed mode  
- Delayed transmit control  
3-wire SPI mode  
- SPiSTE inversion for digital audio interface receive mode on devices with two SPI modules

# 18.1.2 Block Diagram

Figure 18-1 shows the SPI CPU interfaces.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/581c218ed0dbb2ddc1feee2a413f53ae31d3a93c114e02a67901b36d0cdda278.jpg)  
Figure 18-1. SPI CPU Interface

# 18.2 System-Level Integration

This section describes the various functionality that is applicable to the device integration. These features require configuration of other modules in the device that are not within the scope of this chapter.

# 18.2.1 SPI Module Signals

Table 18-1 classifies and provides a summary of the SPI module signals.

Table 18-1. SPI Module Signal Summary  

<table><tr><td>Signal Name</td><td>Description</td></tr><tr><td colspan="2">External Signals</td></tr><tr><td>SPICLK</td><td>SPI clock</td></tr><tr><td>SPISIMO</td><td>SPI slave in, master out</td></tr><tr><td>SPISOMI</td><td>SPI slave out, master in</td></tr><tr><td>SPISTE</td><td>SPI slave transmit enable</td></tr><tr><td colspan="2">Control</td></tr><tr><td>SPI Clock Rate</td><td>LSPCLK</td></tr><tr><td colspan="2">Interrupt Signals</td></tr><tr><td rowspan="2">SPIINT/SPIRXINT</td><td>Transmit interrupt/Receive Interrupt in non FIFO mode (referred to as SPIINT)</td></tr><tr><td>Receive interrupt in FIFO mode</td></tr><tr><td>SPITXINT</td><td>Transmit interrupt in FIFO mode</td></tr><tr><td colspan="2">DMA Triggers</td></tr><tr><td>SPITXDMA</td><td>Transmit request to DMA</td></tr><tr><td>SPIRXDMA</td><td>Receive request to DMA</td></tr></table>

# Special Considerations

The SPISTE signal provides the ability to gate any spurious clock and data pulses when the SPI is in slave mode. An active SPISTE will not allow the slave to receive data. This prevents the SPI slave from losing synchronization with the master. It is this reason that TI does not recommend that the SPISTE always be tied to the active state.

If the SPI slave does ever lose synchronization with the master, toggling SPISWRESET will reset internal bit counter as well as the various status flags in the module. By resetting the bit counter, the SPI will interpret the next clock transition as the first bit of a new transmission. The register bit fields which are reset by SPISWRESET can be found in Section 18.5

# Configuring a GPIO to emulate SPiSTe

In many systems, a SPI master may be connected to multiple SPI slaves using multiple instances of SPISTE. Though this SPI module does not natively support multiple SPISTE signals, it is possible to emulate this behavior in software using GPIOs. In this configuration, the SPI must be configured as the master. Rather than using the GPIO Mux to select SPISTE, the application would configure pins to be GPIO outputs, one GPIO per SPI slave. Before transmitting any data, the application would drive the desired GPIO to the active state. Immediately after the transmission has been completed, the GPIO chip select would be driven to the inactive state. This process can be repeated for many slaves which share the SPICLK, SPISIMO, and SPISOMI lines.

# 18.2.2 Configuring Device Pins

The GPIO mux registers must be configured to connect this peripheral to the device pins. To avoid glitches on the pins, the GPyGMUX bits must be configured first (while keeping the corresponding GPyMUX bits at the default of zero), followed by writing the GPyMUX register to the desired value.

Some IO functionality is defined by GPIO register settings independent of this peripheral. For input signals, the GPIO input qualification should be set to asynchronous mode by setting the appropriate GPxQSELn register bits to 11b. The internal pullups can be configured in the GPyPUD register.

See the GPIO chapter for more details on GPIO mux and settings.

# 18.2.2.1 GPIOs Required for High-Speed Mode

The high-speed mode of the SPI is available on the specified GPIO mux options in the device datasheet. To enable the high-speed enhancements, set SPICCR.HS_MODE to 1. Ensure that the capacitive loading on the pin does not exceed the value stated in the device Data Manual.

When not operating in high-speed mode, or if the capacitive loading on the pins exceed the value stated in the device Data Manual, SPICCR.HS_MODE should be set to 0.

# 18.2.3 SPI Interrupts

This section includes information on the available interrupts present in the SPI module.

The SPI module contains two interrupt lines: SPIINT/SPIRXINT and SPITXINT. When the SPI is operating in non-FIFO mode, all available interrupts are routed together to generate the single SPIINT interrupt. When FIFO mode is used, both SPIRXINT and SPITXINT can be generated.

# SPIINT/SPIRXINT

When the SPI is operating in non-FIFO mode, the interrupt generated is called SPIINT. If FIFO enhancements are enabled, the interrupt is called SPIRXINT. These interrupts share the same interrupt vector in the Peripheral Interrupt Expansion (PIE) block.

In non-FIFO mode, two conditions can trigger an interrupt: a transmission is complete (INT_FLAG), or there is overrun in the receiver (OVERRUN_FLAG). Both of these conditions share the same interrupt vector: SPIINT.

The transmission complete flag (INT_FLAG) indicates that the SPI has completed sending or receiving the last bit and is ready to be serviced. At the same time this bit is set, the received character is placed in the receiver buffer (SPIRXBUF). The INT_FLAG will generate an interrupt on the SPIINT vector if the SPIINTENA bit is set.

The receiver overrun flag (OVERRUN_FLAG) indicates that a transmit or receive operation has completed before the previous character has been read from the buffer. The OVERRUN_FLAG will generate an interrupt on the SPIINT vector if the OVERRIDEINTENA bit is set and OVERRIDE_FLAG was previously cleared.

In FIFO mode, the SPI can interrupt the CPU upon a match condition between the current receive FIFO status (RXFFST) and the receive FIFO interrupt level (RXFFIL). If RXFFST is greater than or equal to RXFFIL, the receive FIFO interrupt flag (RXFFINT) will be set. SPIRXINT will be triggered in the PIE block if RXFFINT is set and the receive FIFO interrupt is enabled (RXFFIENA = 1).

# SPITXINT

The SPITXINT interrupt is not available when the SPI is operating in non-FIFO mode.

In FIFO mode, the SPITXINT behavior is similar to the SPIRXINT. SPITXINT is generated upon a match condition between the current transmit FIFO status (TXFFST) and the transmit FIFO interrupt level (TXFFIL). If TXFFST is less than or equal to TXFFIL, the transmit FIFO interrupt flag (TXFFINT) will be set. SPITXINT will be triggered in the PIE block if TXFFINT is set and the transmit FIFO interrupt is enabled in the SPI module (TXFFIENA = 1).

Figure 18-2 and Table 18-2 show how these control bits influence the SPI interrupt generation.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/e7c7fa2019ffc5ed330e5b1464f19e4acd3a65d4824f3460b661997b526187ce.jpg)  
Figure 18-2. SPI Interrupt Flags and Enable Logic Generation

Table 18-2. SPI Interrupt Flag Modes  

<table><tr><td>FIFO Options</td><td>SPI interrupt Source</td><td>Interrupt Flags</td><td>Interrupt Enables</td><td>FIFO Enable (SPIFFENA)</td><td>Interrupt(1)Line</td></tr><tr><td rowspan="3">SPI without FIFO</td><td>Receive overrun</td><td>RXOVRN</td><td>OVRINTENA</td><td>0</td><td>SPIRXINT</td></tr><tr><td>Data receive</td><td>SPIINT</td><td>SPIINTENA</td><td>0</td><td>SPIRXINT</td></tr><tr><td>Transmit empty</td><td>SPIINT</td><td>SPIINTENA</td><td>0</td><td>SPIRXINT</td></tr><tr><td rowspan="2">SPI FIFO mode</td><td>FIFO receive</td><td>RXFFIL</td><td>RXFFIENA</td><td>1</td><td>SPIRXINT</td></tr><tr><td>Transmit empty</td><td>TXFFIL</td><td>TXFFIENA</td><td>1</td><td>SPITXINT</td></tr></table>

(1) In non-FIFO mode, SPIRXINT is the same name as the SPlINT interrupt in 28x devices.

# 18.2.4 DMA Support

Both the CPU and DMA have access to the SPI data registers via the internal peripheral bus. This access is limited to 16-bit register read/writes. Each SPI module can generate two DMA events, SPITXDMA and SPIRXDMA. The DMA events are controlled by configuring the SPIFTX.TXFFIL and SPIFFRX.RXFFIL appropriately. SPITXDMA activates when TXFFST is less than the interrupt level (TXFFIL). SPIRXDMA activates when RXFFST is greater than or equal to the interrupt level (RXFFIL).

The SPI must have FIFO enhancements enabled in order for the DMA triggers to be generated.

For more information on configuring the SPI for DMA transfers refer to Section 18.3.8.

Figure 18-3 is a block diagram showing the DMA trigger generation from the SPI module.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/a3e5fb8a845e60ceeff9bfc8bf1ba463d15edb939bc82df47e3246942c5690e6.jpg)  
Figure 18-3. SPI DMA Trigger Diagram

# 18.3 SPI Operation

This section describes the various modes of operation of the SPI. Included are explanations of the operational modes, interrupts, data format, clock sources, and initialization. Typical timing diagrams for data transfers are given.

# 18.3.1 Introduction to Operation

Figure 18-4 shows typical connections of the SPI for communications between two controllers: a master and a slave.

The master transfers data by sending the SPICLK signal. For both the slave and the master, data is shifted out of the shift registers on one edge of the SPICLK and latched into the shift register on the opposite SPICLK clock edge. If the CLK_PHASE bit is high, data is transmitted and received a half-cycle before the SPICLK transition. As a result, both controllers send and receive data simultaneously. The application software determines whether the data is meaningful or dummy data. There are three possible methods for data transmission:

- Master sends data; slave sends dummy data.  
- Master sends data; slave sends data.  
- Master sends dummy data; slave sends data.

The master can initiate data transfer at any time because it controls the SPICLK signal. The software, however, determines how the master detects when the slave is ready to broadcast data.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/3ab438db0ac8bb824ecaff85c6ce2d4fb90a875dd27fc4540f08ee68a61cda7a.jpg)  
Figure 18-4. SPI Master/Slave Connection

The SPI can operate in master or slave mode. The MASTER_SLAVE bit selects the operating mode and the source of the SPICLK signal.

# 18.3.2 Master Mode

In master mode (MASTER_SLAVE = 1), the SPI provides the serial clock on the SPICLK pin for the entire serial communications network. Data is output on the SPISIMO pin and latched from the SPISOMI pin.

The SPIBRR register determines both the transmit and receive bit transfer rate for the network. SPIBRR can select 125 different data transfer rates.

Data written to SPIDAT or SPITXBUF initiates data transmission on the SPISIMO pin, MSB (most significant bit) first. Simultaneously, received data is shifted through the SPISOMI pin into the LSB (least significant bit) of SPIDAT. When the selected number of bits has been transmitted, the received data is transferred to the SPIRXBUF (buffered receiver) for the CPU to read. Data is stored right-justified in SPIRXBUF.

When the specified number of data bits has been shifted through SPIDAT, the following events occur:

- SPIDAT contents are transferred to SPIRXBUF.  
- INT_FLAG bit is set to 1.  
- If there is valid data in the transmit buffer SPITXBUF, as indicated by the Transmit Buffer Full Flag (BUFFULL_FLAG), this data is transferred to SPIDAT and is transmitted; otherwise, SPICLK stops after all bits have been shifted out of SPIDAT.  
- If the SPIINTENA bit is set to 1, an interrupt is asserted.

In a typical application, the SPiSTE pin serves as a chip-enable pin for a slave SPI device. This pin is driven low by the master before transmitting data to the slave and is taken high after the transmission is complete.

Figure 18-5 is a block diagram of the SPI in master mode. It shows the basic control blocks available in SPI master mode.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/f7b60622575a2e68a13c58022e38d5367e246e63194b3895632c7ac4feed82f7.jpg)  
Figure 18-5. SPI Module Master Configuration

# 18.3.3 Slave Mode

In slave mode (MASTER_SLAVE = 0), data shifts out on the SPISOMI pin and in on the SPISIMO pin. The SPICLK pin is used as the input for the serial shift clock, which is supplied from the external network master. The transfer rate is defined by this clock. The SPICLK input frequency should be no greater than the LSPCLK frequency divided by 4.

Data written to SPIDAT or SPITXBUF is transmitted to the network when appropriate edges of the SPICLK signal are received from the network master. Data written to the SPITXBUF register will be transferred to the SPIDAT register when all bits of the character to be transmitted have been shifted out of SPIDAT. If no character is currently being transmitted when SPITXBUF is written to, the data will be transferred immediately to SPIDAT. To receive data, the SPI waits for the network master to send the SPICLK signal and then shifts the data on the SPISIMO pin into SPIDAT. If data is to be transmitted by the slave simultaneously, and SPITXBUF has not been previously loaded, the data must be written to SPITXBUF or SPIDAT before the beginning of the SPICLK signal.

When the TALK bit is cleared, data transmission is disabled, and the output line (SPISOMI) is put into the high-impedance state. If this occurs while a transmission is active, the current character is completely transmitted even though SPISOMI is forced into the high-impedance state. This ensures that the SPI is still able to receive incoming data correctly. This TALK bit allows many slave devices to be tied together on the network, but only one slave at a time is allowed to drive the SPISOMI line.

The SPISTE pin operates as the slave-select pin. An active-low signal on the SPISTE pin allows the slave SPI to transfer data to the serial data line; an inactive- high signal causes the slave SPI serial shift register to stop and its serial output pin to be put into the high-impedance state. This allows many slave devices to be tied together on the network, although only one slave device is selected at a time.

Figure 18-6 is a block diagram of the SPI in slave mode. It shows the basic control blocks available in SPI slave mode.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/e2e4ebbd261ddf1cce571489b377a3eaebfe0a03ec78507875a773d4f31cda65.jpg)  
Figure 18-6. SPI Module Slave Configuration

# 18.3.4 Data Format

The four-bit SPICHAR register field specifies the number of bits in the data character (1 to 16). This information directs the state control logic to count the number of bits received or transmitted to determine when a complete character has been processed.

The following statements apply to characters with fewer than 16 bits:

- Data must be left-justified when written to SPIDAT and SPITXBUF.  
Data read back from SPIRXBUF is right-justified.  
- SPIRXBUF contains the most recently received character, right-justified, plus any bits that remain from

previous transmission(s) that have been shifted to the left (shown in Example 18-1).

# Example 18-1. Transmission of Bit From SPIRXBUF

# Conditions:

1. Transmission character length  $= 1$  bit (specified in bits SPICHAR)  
2. The current value of SPIDAT = 737Bh

<table><tr><td colspan="17">SPIDAT (before transmission)</td></tr><tr><td></td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td></td></tr><tr><td colspan="17">SPIDAT (after transmission)</td></tr><tr><td>(TXed) 0 ←</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>x(1)</td><td>← (RXed)</td></tr><tr><td colspan="17">SPIRXBUF (after transmission)</td></tr><tr><td></td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>x(1)</td><td></td></tr></table>

(1)  $x = 1$  if SPISOMI data is high;  $x = 0$  if SPISOMI data is low; master mode is assumed.

# 18.3.5 Baud Rate Selection

The SPI module supports 125 different baud rates and four different clock schemes. Depending on whether the SPI clock is in slave or master mode, the SPICLK pin can receive an external SPI clock signal or provide the SPI clock signal, respectively.

- In the slave mode, the SPI clock is received on the SPICLK pin from the external source, and can be no greater than the LSPCLK frequency divided by 4.  
- In the master mode, the SPI clock is generated by the SPI and is output on the SPICLK pin, and can be no greater than the LSPCLK frequency divided by 4.

NOTE: The baud rate should be configured to not exceed the maximum rated GPIO toggle frequency. Refer to the device Data Manual for the maximum GPIO toggle frequency

Example 18-2 shows how to determine the SPI baud rates.

# Example 18-2. Baud Rate Determination

For SPIBRR = 3 to 127:

$$
\text {S P I B a u d R a t e} = \frac {\text {L S P C L K}}{(\text {S P I B R R} + 1)} \tag {6}
$$

For SPIBRR  $= 0$  1, or 2:

$$
\text {S P I B a u d R a t e} = \frac {\text {L S P C L K}}{4} \tag {7}
$$

where:

LSPCLK = Low-speed peripheral clock frequency of the device

SPIBRR = Contents of the SPIBRR in the master SPI device

To determine what value to load into SPIBRR, you must know the device system clock (LSPCLK) frequency (which is device-specific) and the baud rate at which you will be operating.

The following example shows how to calculate the baud rate of the SPI module in standard SPI mode (HS_MODE=0).

# Example 18-3. Baud Rate Calculation in Non-High Speed Mode (HS_MODE=0)

$$
\begin{array}{l} S P I B a u d R a t e = \frac {L S P C L K}{S P I B R R + 1 ^ {\prime}} L S P C L K = 5 0 M H z \\ = \frac {5 0 \times 1 0 ^ {6}}{3 + 1} \\ = 1 2. 5 \text {M b p s} \tag {8} \\ \end{array}
$$

# 18.3.6 SPI Clocking Schemes

The clock polarity select bit (CLKPOLARITY) and the clock phase select bit (CLK_PHASE) control four different clocking schemes on the SPICLK pin. CLKPOLARITY selects the active edge, either rising or falling, of the clock. CLK_PHASE selects a half-cycle delay of the clock. The four different clocking schemes are as follows:

- Falling Edge Without Delay. The SPI transmits data on the falling edge of the SPICLK and receives data on the rising edge of the SPICLK.  
- Falling Edge With Delay. The SPI transmits data one half-cycle ahead of the falling edge of the SPICLK signal and receives data on the falling edge of the SPICLK signal.  
- Rising Edge Without Delay. The SPI transmits data on the rising edge of the SPICLK signal and receives data on the falling edge of the SPICLK signal.  
- Rising Edge With Delay. The SPI transmits data one half-cycle ahead of the rising edge of the SPICLK signal and receives data on the rising edge of the SPICLK signal.

The selection procedure for the SPI clocking scheme is shown in Table 18-3. Examples of these four clocking schemes relative to transmitted and received data are shown in Figure 18-7.

Table 18-3. SPI Clocking Scheme Selection Guide  

<table><tr><td>SPICLK Scheme</td><td>CLKPOLARITY</td><td>CLK_PHASE(1)</td></tr><tr><td>Rising edge without delay</td><td>0</td><td>0</td></tr><tr><td>Rising edge with delay</td><td>0</td><td>1</td></tr><tr><td>Falling edge without delay</td><td>1</td><td>0</td></tr><tr><td>Falling edge with delay</td><td>1</td><td>1</td></tr></table>

(1) The description of CLK_PHASE and CLKPOLARITY differs between manufacturers. For proper operation, select the desired waveform to determine the clock phase and clock polarity settings.

Figure 18-7. SPICLK Signal Options  
![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/9c7b0fb3aa7fa6d666e89447a05fa866ce55d3b9c1bc7e7ec7966aa3539b35ed.jpg)  
Note: Previous data bit

Figure 18-8. SPI: SPICLK-LSPCLK Characteristic When (BRR + 1) is Odd, BRR > 3, and CLKPOLARITY = 1  
![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/9c6cb6d7a1f8a291298b9d7ae532a295d1040ccf43e33299b6ff734e83d09549.jpg)  
SPICLK symmetry is retained only when the result of (SPIBRR+1) is an even value. When (SPIBRR + 1) is an odd value and SPIBRR is greater than 3, SPICLK becomes asymmetrical. The low pulse of SPICLK is one LSPCLK cycle longer than the high pulse when CLKPOLARITY bit is clear (0). When CLKPOLARITY bit is set to 1, the high pulse of the SPICLK is one LSPCLK cycle longer than the low pulse, as shown in Figure 18-8.

# 18.3.7 SPI FIFO Description

The following steps explain the FIFO features and help with programming the SPI FIFOs:

1. Reset. At reset the SPI powers up in standard SPI mode and the FIFO function is disabled. The FIFO registers SPIFFTX, SPIFFRX and SPIFFCT remain inactive.  
2. Standard SPI. The standard 28x SPI mode will work with SPIINT/SPIRXINT as the interrupt source.  
3. Mode change. FIFO mode is enabled by setting the SPIFFENA bit to 1 in the SPIFTX register. SPIRST can reset the FIFO mode at any stage of its operation.  
4. Active registers. All the SPI registers and SPI FIFO registers SPIFFTX, SPIFFRX, and SPIFFCT will be active.  
5. Interrupts. FIFO mode has two interrupts one for the transmit FIFO, SPITXINT and one for the receive FIFO, SPIRXINT. SPIRXINT is the common interrupt for SPI FIFO receive, receive error and receive FIFO overflow conditions. The single SPRINT for both transmit and receive sections of the standard SPI will be disabled and this interrupt will service as SPI receive FIFO interrupt. For more information, refer to Section 18.2.3

6. Buffers. Transmit and receive buffers are each supplemented with a 16 word FIFO. The one-word transmit buffer (SPITXBUF) of the standard SPI functions as a transition buffer between the transmit FIFO and shift register. The one-word transmit buffer will be loaded from transmit FIFO only after the last bit of the shift register is shifted out.  
7. Delayed transfer. The rate at which transmit words in the FIFO are transferred to transmit shift register is programmable. The SPIFFCT register bits (7-0) FFTXDLY7-FFTXDLY0 define the delay between the word transfer. The delay is defined in number SPI serial clock cycles. The 8-bit register could define a minimum delay of 0 SPICLK cycles and a maximum of 255 SPICLK cycles. With zero delay, the SPI module can transmit data in continuous mode with the FIFO words shifting out back to back. With the 255 clock delay, the SPI module can transmit data in a maximum delayed mode with the FIFO words shifting out with a delay of 255 SPICLK cycles between each word. The programmable delay facilitates glueless interface to various slow SPI peripherals, such as EEPROMs, ADC, DAC, and so on.  
8. FIFO status bits. Both transmit and receive FIFOs have status bits TXFFST or RXFFST that define the number of words available in the FIFOs at any time. The transmit FIFO reset bit (TXFIFO) and receive reset bit (RXFIFO) will reset the FIFO pointers to zero when these bits are set to 1. The FIFOs will resume operation from start once these bits are cleared to zero.  
9. Programmable interrupt levels. Both transmit and receive FIFOs can generate CPU interrupts and DMA triggers. The transmit interrupt (SPITXINT) is generated whenever the transmit FIFO status bits (TXFFST) match (less than or equal to) the interrupt trigger level bits (TXFFIL). The receive interrupt (SPIRXINT) is generated whenever the receive FIFO status bits (RXFFST) match (greater than or equal to) the interrupt trigger level RXFFIL. This provides a programmable interrupt trigger for transmit and receive sections of the SPI. The default value for these trigger level bits will be 0x11111 for receive FIFO and 0x00000 for transmit FIFO, respectively.

# 18.3.8 SPI DMA Transfers

# 18.3.8.1 Transmitting Data Using SPI with DMA

When using the DMA with the TX FIFO, the DMA Burst Size (DMA_BURST_SIZE) should be no greater than 16 - TXFFIL in order to prevent the DMA from writing to an already full FIFO. This will lead to data loss and is not recommended.

For complete data transmission, please follow these steps:

1. Calculate the total number or words to be transmitted. [NUMWORDS]  
2. Decide the transmit FIFO level. [TXFFIL]  
3. Calculate the number of DMA transfers. [DMA_TRANSFER_SIZE]  
4. Calculate the size of the DMA Burst. [DMA_BURST_SIZE]  
5. Configure DMA using calculated values.  
6. Configure SPI with FIFO using the calculated values.

To transfer 128 words to SPI using the DMA:

NUMWORDS: 128

TXFFIL:8

DMA_TRANSFER_SIZE: (NUMWORDS /TXFFIL) - 1 = (128/8) - 1 = 15 (16 transfers)

DMA_BURST_SIZE: (16 - TXFFIL) - 1 = (16 - 8) - 1 = 7 (8 words per burst)

NOTE: Avoid setting TXFFIL to 0h or 10h to ensure proper DMA configuration.

# 18.3.8.2 Receiving Data Using SPI with DMA

When using the DMA with the RX FIFO, the DMA Burst Size (BURST_SIZE) should be no greater than RXFFIL in order to prevent the DMA from reading from an empty FIFO. To ensure that the DMA correctly receives all data from the RX FIFO, the DMA Burst Size should equal RXFFIL and also be an integer divisor of the total number of SPI transmissions.

For complete data reception, please follow these steps:

1. Calculate the number of words to be received. [NUMWORDS]  
2. Calculate the necessary FIFO level [RXFFIL]  
3. Calculate the total number of DMA transfers. [DMA_TRANSFER_SIZE]  
4. Calculate the size of the DMA Burst. [DMA_BURST_SIZE]  
5. Configure DMA using the calculated values.  
6. Configure SPI with FIFO using the calculated values.

```txt
To receive 200 words from SPI using the DMA:  
NUMWORDS = 200  
RXFFIL: 4  
DMA_TRANSFER_SIZE: (NUMWORDS / RXFFIL) - 1 = (200/4) - 1 = 49 (50 transfers)  
DMA_BURST_SIZE = RXFFIL - 1 = 3 (4 words per burst)
```

NOTE: Avoid setting RXFFIL to 0h to ensure proper DMA configuration.

# 18.3.9 SPI High-Speed Mode

The SPI module is capable of reaching full-duplex communication speeds up to LSPCLK/4 (where LSPCLK equals SYSCLK). For the maximum rated speed, refer the device Data Manual.

In order to achieve the maximum full-duplex speeds, the following restrictions are placed on the design:

- Single master to single slave configuration is supported.  
- Loading on the pins must not exceed the value stated in the device Data Manual.

When configuring the GPIOs to support High-Speed mode, refer to Section 18.2.2.1 for more information.

# 18.3.10 SPI 3-Wire Mode Description

SPI 3-wire mode allows for SPI communication over three pins instead of the normal four pins.

In master mode, if the TRIWIRE bit is set, enabling 3-wire SPI mode, SPISIMOx becomes the bi-directional SPIMOMlx (SPI master out, master in) pin, and SPISOMlx is no longer used by the SPI. In slave mode, if the TRIWIRE bit is set, SPISOMlx becomes the bi-directional SPISISOx (SPI slave in, slave out) pin, and SPISIMOx is no longer used by the SPI.

Table 18-4 indicates the pin function differences between 3-wire and 4-wire SPI mode for a master and slave SPI.

Table 18-4. 4-wire vs. 3-wire SPI Pin Functions  

<table><tr><td>4-wire SPI</td><td>3-wire SPI (Master)</td><td>3-wire SPI(Slave)</td></tr><tr><td>SPICLKx</td><td>SPICLKx</td><td>SPICLKx</td></tr><tr><td>SPISTEx</td><td>SPISTEx</td><td>SPISTEx</td></tr><tr><td>SPISIMOx</td><td>SPIMOMIx</td><td>Free</td></tr><tr><td>SPISOMIx</td><td>Free</td><td>SPISISOx</td></tr></table>

Because in 3-wire mode, the receive and transmit paths within the SPI are connected, any data transmitted by the SPI module is also received by itself. The application software must take care to perform a dummy read to clear the SPI data register of the additional received data.

The TALK bit plays an important role in 3-wire SPI mode. The bit must be set to transmit data and cleared prior to reading data. In master mode, in order to initiate a read, the application software must write dummy data to the SPI data register (SPIDAT or SPIRXBUF) while the TALK bit is cleared (no data is transmitted out the SPIMOMI pin) before reading from the data register.

Figure 18-9 and Figure 18-10 illustrate 3-wire master and slave mode.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/f3111ced1e95d12e82156738c06e86c37d36a84630571df04402298fcf1a5e51.jpg)  
Figure 18-9. SPI 3-wire Master Mode

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/a62d63496c18cb0401e4cc51d5b0c796884a1cdb8914f92e372ff85c7a98d3ed.jpg)  
Figure 18-10. SPI 3-wire Slave Mode

Table 18-5 indicates how data is received or transmitted in the various SPI modes while the TALK bit is set or cleared.  
Table 18-5. 3-Wire SPI Pin Configuration  

<table><tr><td>Pin Mode</td><td>SPIPRI[TRIWIRE]</td><td>SPICTL[TALK]</td><td>SPISIMO</td><td>SPISOMI</td></tr><tr><td colspan="5">Master Mode</td></tr><tr><td>4-wire</td><td>0</td><td>X</td><td>TX</td><td>RX</td></tr><tr><td>3-pin mode</td><td>1</td><td>0</td><td>RX</td><td>Disconnect from SPI</td></tr><tr><td></td><td></td><td>1</td><td>TX/RX</td><td></td></tr><tr><td colspan="5">Slave Mode</td></tr><tr><td>4-wire</td><td>0</td><td>X</td><td>RX</td><td>TX</td></tr><tr><td>3-pin mode</td><td>1</td><td>0</td><td>Disconnect from SPI</td><td>RX</td></tr><tr><td></td><td></td><td>1</td><td></td><td>TX/RX</td></tr></table>

# 18.4 Programming Procedure

This section describes the procedure for configuring the SPI for the various modes of operation.

# 18.4.1 Initialization Upon Reset

A system reset forces the SPI peripheral into the following default configuration:

- Unit is configured as a slave module (MASTER_SLAVE = 0)  
Transmit capability is disabled (TALK = 0)  
Data is latched at the input on the falling edge of the SPICLK signal  
- Character length is assumed to be one bit  
- SPI interrupts are disabled  
Data in SPIDAT is reset to 0000h

# 18.4.2 Configuring the SPI

This section describes the procedure in which to configure the SPI module for operation. To prevent unwanted and unforeseen events from occurring during or as a result of initialization changes, clear the SPISWRESET bit before making initialization changes, and then set this bit after initialization is complete. While the SPI is held in reset (SPISWRESET = 0), configuration may be changed in any order. The following list shows the SPI configuration procedure in a logical order. However, the SPI registers can be written with single 16-bit writes, so the order is not required with the exception of SPISWRESET.

To change the SPI configuration:

Step 1. Clear the SPI Software Reset bit (SPISWRESET) to 0 to force the SPI to the reset state.

Step 2. Configure the SPI as desired:

- Select either master or slave mode (MASTER_SLAVE).  
- Choose SPICLK polarity and phase (CLKPOLARITY and CLK_PHASE).  
- Set the desired baud rate (SPIBRR).  
- Enable high speed mode if desired (HS_MODE).  
- Set the SPI character length (SPICHAR).  
- Clear the SPI Flags (OVERRUN_FLAG, INT_FLAG).  
- Enable SPISTE inversion (STEINV) if needed.  
- Enable 3-wire mode (TRIWIRE) if needed.  
If using FIFO enhancements:

- Enable the FIFO enhancements (SPIFFENA).  
- Clear the FIFO Flags (TXFFINTCLR, RXFFOVFCLR, and RXFFINTCLR).  
- Release transmit and receive FIFO resets (TXFIFO and RXFIFORESET).  
- Release SPI FIFO channels from reset (SPIRST).

Step 3. If interrupts are used:

- In non-FIFO mode, enable the receiver overrun and/or SPI interrupts (OVERRUNINTENA and SPIINTENA).  
- In FIFO mode, set the transmit and receive interrupt levels (TXFFIL and RXFFIL) then enable the interrupts (TXFFIENA and RXFFIENA).

Step 4. Set SPISWRESET to 1 to release the SPI from the reset state.

NOTE: Do not change the SPI configuration when communication is in progress.

# 18.4.3 Configuring the SPI for High-Speed Mode

In order to achieve the maximum rated speeds, the following settings must be made. This example assumes that the device is operating at 100 MHz.

Set LSPCLK equal to SYSCLK:

_clkCfgRegs.LOSPCP.bit.LSPCLKDIV = 0;

Select the appropriate Pin Mux options in GPIO_CTRL_REGS.

During the SPI configuration procedure:

Set HS_MODE to 1.

SpiaRegs.SPICCR.bit.HS_MODE = 0x1;

Set SPIBRR to 3. SPICLK = LSPCLK/(SPIBRR+1) = 25MHz

SpiaRegs.SPIBRR = 0x3;

There are no other differences in the configuration from normal SPI operation. Sending and receiving data, interrupts, and DMA operation will operate without change.

# 18.4.4 Data Transfer Example

The timing diagram shown in Figure 18-11 illustrates an SPI data transfer between two devices using a character length of five bits with the SPICLK being symmetrical.

The timing diagram with SPICLK asymmetrical (Figure 18-8) shares similar characterizations with Figure 18-11 except that the data transfer is one LSPCLK cycle longer per bit during the low pulse (CLKPOLARITY = 0) or during the high pulse (CLKPOLARITY = 1) of the SPICLK.

Figure 18-11 is applicable for 8-bit SPI only and is not for C28x devices that are capable of working with 16-bit data. The figure is shown for illustrative purposes only.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/1e10ead1a1d97220a142e902043214c98f766c7a2e254ee8cdb3daf7f797d80d.jpg)  
Figure 18-11. Five Bits per Character

A Slave writes 0D0h to SPIDAT and waits for the master to shift out the data.  
B Master sets the slave SPISTE signal low (active).  
C Master writes 058h to SPIDAT, which starts the transmission procedure.  
D First byte is finished and sets the interrupt flags.  
E Slave reads 0Bh from its SPIRXBUF (right-justified).  
F Slave writes 04Ch to SPIDAT and waits for the master to shift out the data.  
G Master writes 06Ch to SPIDAT, which starts the transmission procedure.  
H Master reads 01Ah from the SPIRXBUF (right-justified).

Second byte is finished and sets the interrupt flags.  
J Master reads 89h and the slave reads 8Dh from their respective SPIRXBUF. After the user's software masks off the unused bits, the master receives 09h and the slave receives 0Dh.  
K Master clears the slave SPISTE signal high (inactive).

# 18.4.5 SPI 3-Wire Mode Code Examples

In addition to the normal SPI initialization, to configure the SPI module for 3-wire mode, the TRIWIRE bit (SPIPRI.0) must be set to 1. After initialization, there are several considerations to take into account when transmitting and receiving data in 3-wire master and slave mode. The following examples demonstrate these considerations.

In 3-wire master mode, SPICLKx, SPISTEx, and SPISIMOx pins must be configured as SPI pins (SPISOMlx pin can be configured as non-SPI pin). When the master transmits, it receives the data it transmits (because SPISIMOx and SPISOMlx are connected internally in 3-wire mode). Therefore, the junk data received must be cleared from the receive buffer every time data is transmitted.

# Example 18-4. 3-Wire Master Mode Transmit

Uint16 data;

Uint16 dummy;

Example 18-4. 3-Wire Master Mode Transmit (continued)  
```txt
SpiaRegs.SPICTL.bit.TALK = 1; // Enable Transmit path  
SpiaRegs.SPITXBUF = data; // Master transmits data  
while(SpiaRegs.SPIISTS.bit.INT_FLAG != 1) {} // Waits until data rx'd  
dummy = SpiaRegs.SPIRXBUF; // Clears junk data from itself  
// bc it rx'd same data tx'd
```

To receive data in 3-wire master mode, the master must clear the TALK (SPICTL.1) bit to 0 to close the transmit path and then transmit dummy data in order to initiate the transfer from the slave. Because the TALK bit is 0, unlike in transmit mode, the master dummy data does not appear on the SPISIMOx pin, and the master does not receive its own dummy data. Instead, the data from the slave is received by the master.

Example 18-5. 3-Wire Master Mode Receive  
```txt
Uint16 rdata;   
Uint16 dummy; SpiaRegs.SPICTL.bit.TALK  $= 0$  // Disable Transmit path SpiaRegs.SPITXBUF  $\equiv$  dummy; // Send dummy to start tx /NOTE: because TALK  $= 0$  data does not tx onto SPISIMOA pin while(SpiaRegs.SPISTS.bit.INT_FLAG  $! = 1$  } // Wait until data received rdata  $=$  SpiaRegs.SPIRXBUF; // Master reads data
```

In 3-wire slave mode, SPICLKx, SPISTEx, and SPISOMIx pins must be configured as SPI pins (SPISIMOx pin can be configured as non-SPI pin). Like in master mode, when transmitting, the slave receives the data it transmits and must clear this junk data from its receive buffer.

Example 18-6. 3-Wire Slave Mode Transmit  
```txt
Uint16 data;   
Uint16 dummy; SpiaRegs.SPICTL.bit.TALK  $= 1$  //Enable Transmit path SpiaRegs.SPITXBUF  $\equiv$  data; // Slave transmits data while(SpiaRegs.SPISTS.bit.INT_FLAG !=1){//Wait until data rx'd dummy  $=$  SpiaRegs.SPIRXBUF; //Clears junk data from itself
```

As in 3-wire master mode, the TALK bit must be cleared to 0. Otherwise, the slave receives data normally.

Example 18-7. - 3-Wire Slave Mode Receive  
```javascript
Uint16 rdata; SpiaRegs.SPICTL.bit.TALK = 0; // Disable Transmit path while(SpiaRegs.SPISTS.bit.INT_FLAG != 1) {} // Waits until data rx'd rdata = SpiaRegs.SPIRXBUF; // Slave reads data
```

# 18.4.6 SPI STEINV Bit in Digital Audio Transfers

On those devices with two SPI modules, enabling the STEINV bit on one of the SPI modules allows the pair of SPIs to receive both left and right-channel digital audio data in slave mode. The SPI module that receives a normal active-low SPISTE signal stores right-channel data, and the SPI module that receives an inverted active-high SPISTE signal stores left-channel data from the master. To receive digital audio data from a digital audio interface receiver, the SPI modules can be connected as shown in Figure 18-12.

NOTE: This configuration is only applicable to slave mode (MASTER_SLAVE = 0). When the SPI is configured as master (MASTER_SLAVE = 1), the STEINV bit will have no effect on the SPISTE pin.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/f98d6ec356c4dbff1d113e9ba0ed225acedaf663e6f8776e4c3546fe26e1c35c.jpg)  
Figure 18-12. SPI Digital Audio Receiver Configuration Using Two SPIs

Standard C28x SPI timing requirements limit the number of digital audio interface formats supported using the 2-SPI configuration with the STEINV bit. See your device-specific data sheet electrical specifications for SPI timing requirements. With the SPI clock phase configured such that the CLKPOLARITY bit is 0 and the CLK_PHASE 1 (data latched on rising edge of clock), standard right-justified digital audio interface data format is supported as shown in Figure 18-13.

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-17/9c6016a7-84aa-491a-91bc-3a50d812054a/d702d8cb4669245625d233caa51de8b490e311f505f1e0edbeef2f5232915e9d.jpg)  
Figure 18-13. Standard Right-Justified Digital Audio Data Format

# 18.5 SPI Registers

This section describes the Serial Peripheral Interface registers. It is important to note that the SPI registers only allow 16-bit accesses.

# 18.5.1 SPI Base Addresses

Table 18-6. SPI Base Address Table  

<table><tr><td>Device Registers</td><td>Register Name</td><td>Start Address</td><td>End Address</td></tr><tr><td>SpiaRegs</td><td>SPI_REGS</td><td>0x0000_6100</td><td>0x0000_610F</td></tr><tr><td>SpibRegs</td><td>SPI_REGS</td><td>0x0000_6110</td><td>0x0000_611F</td></tr><tr><td>SpicRegs</td><td>SPI_REGS</td><td>0x0000_6120</td><td>0x0000_612F</td></tr></table>

# 18.5.2 SPL_REGS Registers

Table 18-7 lists the SPI_REGS registers. All register offset addresses not listed in Table 18-7 should be considered as reserved locations and the register contents should not be modified.

Table 18-7. SPI_REGS Registers  

<table><tr><td>Offset</td><td>Acronym</td><td>Register Name</td><td>Write Protection</td><td>Section</td></tr><tr><td>0h</td><td>SPICCR</td><td>SPI Configuration Control Register</td><td></td><td>Go</td></tr><tr><td>1h</td><td>SPICTL</td><td>SPI Operation Control Register</td><td></td><td>Go</td></tr><tr><td>2h</td><td>SPISTS</td><td>SPI Status Register</td><td></td><td>Go</td></tr><tr><td>4h</td><td>SPIBRR</td><td>SPI Baud Rate Register</td><td></td><td>Go</td></tr><tr><td>6h</td><td>SPIRXEMU</td><td>SPI Emulation Buffer Register</td><td></td><td>Go</td></tr><tr><td>7h</td><td>SPIRXBUF</td><td>SPI Serial Input Buffer Register</td><td></td><td>Go</td></tr><tr><td>8h</td><td>SPIXBUF</td><td>SPI Serial Output Buffer Register</td><td></td><td>Go</td></tr><tr><td>9h</td><td>SPIDAT</td><td>SPI Serial Data Register</td><td></td><td>Go</td></tr><tr><td>Ah</td><td>SPIFFTX</td><td>SPI FIFO Transmit Register</td><td></td><td>Go</td></tr><tr><td>Bh</td><td>SPIFFRX</td><td>SPI FIFO Receive Register</td><td></td><td>Go</td></tr><tr><td>Ch</td><td>SPIFFCT</td><td>SPI FIFO Control Register</td><td></td><td>Go</td></tr><tr><td>Fh</td><td>SPIPRI</td><td>SPI Priority Control Register</td><td></td><td>Go</td></tr></table>

Complex bit access types are encoded to fit into small table cells. Table 18-8 shows the codes that are used for access types in this section.

Table 18-8. SPI_REGS Access Type Codes  

<table><tr><td>Access Type</td><td>Code</td><td>Description</td></tr><tr><td colspan="3">Read Type</td></tr><tr><td>R</td><td>R</td><td>Read</td></tr><tr><td>RC</td><td>RC</td><td>Read to Clear</td></tr><tr><td colspan="3">Write Type</td></tr><tr><td>W</td><td>W</td><td>Write</td></tr><tr><td>W1C</td><td>W 1C</td><td>Write 1 to clear</td></tr><tr><td colspan="3">Reset or Default Value</td></tr><tr><td>-n</td><td></td><td>Value after reset or the default value</td></tr><tr><td colspan="3">Register Array Variables</td></tr><tr><td>i,j,k,l,m,n</td><td></td><td>When these variables are used in a register name, an offset, or an address, they refer to the value of a register array where the register is part of a group of repeating registers. The register groups form a hierarchical structure and the array is represented with a formula.</td></tr><tr><td>y</td><td></td><td>When this variable is used in a register name, an offset, or an address it refers to the value of a register array.</td></tr></table>

# 18.5.2.1 SPICCR Register (Offset = 0h) [reset = 0h]

SPICCR is shown in Figure 18-14 and described in Table 18-9.

Return to the Summary Table.

SPICCR controls the setup of the SPI for operation.

Figure 18-14. SPICCR Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td colspan="8">RESERVED</td></tr><tr><td colspan="8">R-Oh</td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>SPISWRESET</td><td>CLKPOLARITY</td><td>HS_MODE</td><td>SPILBK</td><td colspan="4">SPICHAR</td></tr><tr><td>R/W-Oh</td><td>R/W-Oh</td><td>R/W-Oh</td><td>R/W-Oh</td><td colspan="4">R/W-Oh</td></tr></table>

Table 18-9. SPICCR Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-8</td><td>RESERVED</td><td>R</td><td>0h</td><td>Reserved</td></tr><tr><td>7</td><td>SPISWRESET</td><td>R/W</td><td>0h</td><td>SPI Software ResetWhen changing configuration, you should clear this bit before the changes and set this bit before resuming operation.Reset type: SYSRSn0h (R/W) = Initialized the SPI operating flags to the reset condition. Specifically, the RECEIVER OVERRIDE Flag bit (SPISTS.7), the SPI INT FLAG bit (SPISTS.6), and the TXBUF FULL Flag bit (SPISTS.5) are cleared. SPISTE will become inactive. SPICLK will be immediately driven to 0 regardless of the clock polarity. The SPI configuration remains unchanged.1h (R/W) = SPI is ready to transmit or receive the next character.When the SPI SW RESET bit is a 0, a character written to the transmitter will not be shifted out when this bit is set. A new character must be written to the serial data register. SPICLK will be returned to its inactive state one SPICLK cycle after this bit is set.</td></tr><tr><td>6</td><td>CLKPOLARITY</td><td>R/W</td><td>0h</td><td>Shift Clock PolarityThis bit controls the polarity of the SPICLK signal. CLOCK POLARITY and POLARITY CLOCK PHASE (SPICTL.3) control four clocking schemes on the SPICLK pin.Reset type: SYSRSn0h (R/W) = Data is output on rising edge and input on falling edge. When no SPI data is sent, SPICLK is at low level. The data input and output edges depend on the value of the CLOCK PHASE bit (SPICTL.3) as follows:- CLOCK PHASE = 0: Data is output on the rising edge of the SPICLK signal. Input data is latched on the falling edge of the SPICLK signal.- CLOCK PHASE = 1: Data is output one half-cycle before the first rising edge of the SPICLK signal and on subsequent falling edges of the SPICLK signal. Input data is latched on the rising edge of the SPICLK signal.1h (R/W) = Data is output on falling edge and input on rising edge. When no SPI data is sent, SPICLK is at high level. The data input and output edges depend on the value of the CLOCK PHASE bit (SPICTL.3) as follows:- CLOCK PHASE = 0: Data is output on the falling edge of the SPICLK signal. Input data is latched on the rising edge of the SPICLK signal.- CLOCK PHASE = 1: Data is output one half-cycle before the first falling edge of the SPICLK signal and on subsequent rising edges of the SPICLK signal. Input data is latched on the falling edge of the SPICLK signal.</td></tr></table>

Table 18-9. SPICCR Register Field Descriptions (continued)  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>5</td><td>HS_MODE</td><td>R/W</td><td>0h</td><td>High Speed Mode Enable BitsThis bit determines if the High Speed mode is enabled. The correct GPIOs should be selected in the GPxGMUX/GPxMUX registers. Reset type: SYSRSn0h (R/W) = SPI High Speed mode disabled. This is the default value after reset.1h (R/W) = SPI High Speed mode enabled,</td></tr><tr><td>4</td><td>SPILBK</td><td>R/W</td><td>0h</td><td>SPI Loopback Mode SelectLoopback mode allows module validation during device testing. This mode is valid only in master mode of the SPI. Reset type: SYSRSn0h (R/W) = SPI loopback mode disabled. This is the default value after reset.1h (R/W) = SPI loopback mode enabled, SIMO/SOMI lines are connected internally. Used for module self-tests.</td></tr><tr><td>3-0</td><td>SPICHAR</td><td>R/W</td><td>0h</td><td>Character Length Control BitsThese four bits determine the number of bits to be shifted in or SPI CHAR0 out as a single character during one shift sequence.SPICHAR = Word length - 1Reset type: SYSRSn0h (R/W) = 1-bit word1h (R/W) = 2-bit word7h (R/W) = 8-bit wordFh (R/W) = 16-bit word</td></tr></table>

# 18.5.2.2 SPECTL Register (Offset = 1h) [reset = 0h]

SPICTL is shown in Figure 18-15 and described in Table 18-10.

Return to the Summary Table.

SPICTL controls data transmission, the SPI's ability to generate interrupts, the SPICLK phase, and the operational mode (slave or master).

Figure 18-15. SPICTL Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td colspan="8">RESERVED</td></tr><tr><td colspan="8">R-Oh</td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td colspan="3">RESERVED</td><td>OVERRUNINT ENA</td><td>CLK_PHASE</td><td>MASTER_SLAVE</td><td>TALK</td><td>SPIINTENA</td></tr><tr><td colspan="3">R-Oh</td><td>R/W-Oh</td><td>R/W-Oh</td><td>R/W-Oh</td><td>R/W-Oh</td><td>R/W-Oh</td></tr></table>

Table 18-10. SPICTL Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-5</td><td>RESERVED</td><td>R</td><td>0h</td><td>Reserved</td></tr><tr><td>4</td><td>OVERRUNINTENA</td><td>R/W</td><td>0h</td><td>Overrun Interrupt Enable
Overrun Interrupt Enable. Setting this bit causes an interrupt to be generated when the RECEIVER OVERRUN Flag bit (SPISTS.7) is set by hardware. Interrupts generated by the RECEIVER OVERRUN Flag bit and the SPI INT FLAG bit (SPISTS.6) share the same interrupt vector.
Reset type: SYSRSn
0h (R/W) = Disable RECEIVER OVERRUN interrupts.
1h (R/W) = Enable RECEIVER_OVERRUN interrupts.</td></tr><tr><td>3</td><td>CLK_PHASE</td><td>R/W</td><td>0h</td><td>SPI Clock Phase Select
This bit controls the phase of the SPICLK signal. CLOCK PHASE and CLOCK POLARITY (SPICCR.6) make four different clocking schemes possible (see clocking figures in SPI chapter). When operating with CLOCK PHASE high, the SPI (master or slave) makes the first bit of data available after SPIDAT is written and before the first edge of the SPICLK signal, regardless of which SPI mode is being used.
Reset type: SYSRSn
0h (R/W) = Normal SPI clocking scheme, depending on the CLOCK POLARITY bit (SPICCR.6).
1h (R/W) = SPICLK signal delayed by one half-cycle. Polarity determined by the CLOCK POLARITY bit.</td></tr><tr><td>2</td><td>MASTER_SLAVE</td><td>R/W</td><td>0h</td><td>SPI Network Mode Control
This bit determines whether the SPI is a network master or slave. SLAVE During reset initialization, the SPI is automatically configured as a network slave.
Reset type: SYSRSn
0h (R/W) = SPI is configured as a slave.
1h (R/W) = SPI is configured as a master.</td></tr></table>

Table 18-10. SPICTL Register Field Descriptions (continued)  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>1</td><td>TALK</td><td>R/W</td><td>0h</td><td>Transmit Enable
The TALK bit can disable data transmission (master or slave) by placing the serial data output in the high-impedance state. If this bit is disabled during a transmission, the transmit shift register continues to operate until the previous character is shifted out. When the TALK bit is disabled, the SPI is still able to receive characters and update the status flags. TALK is cleared (disabled) by a system reset.
Reset type: SYSRSn
0h (R/W) = Enables transmission:
- Slave mode operation: If not previously configured as a general-purpose I/O pin, the SPISOMI pin will be put in the high-impedance state.
- Master mode operation: If not previously configured as a general-purpose I/O pin, the SPISIMO pin will be put in the high-impedance state.
1h (R/W) = Enables transmission For the 4-pin option, ensure to enable the receiver&#x27;s SPISTEn input pin.</td></tr><tr><td>0</td><td>SPIINTENA</td><td>R/W</td><td>0h</td><td>SPI Interrupt Enable
This bit controls the SPI&#x27;s ability to generate a transmit/receive interrupt. The SPI INT FLAG bit (SPISTS.6) is unaffected by this bit.
Reset type: SYSRSn
0h (R/W) = Enables the interrupt.
1h (R/W) = Enables the interrupt.</td></tr></table>

# 18.5.2.3 SPISTS Register (Offset = 2h) [reset = 0h]

SPISTS is shown in Figure 18-16 and described in Table 18-11.

Return to the Summary Table.

SPISTS constrains interrupt and status bits.

Figure 18-16. SPISTS Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td colspan="8">RESERVED</td></tr><tr><td colspan="8">R-Oh</td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>OVERRUN_FLAG</td><td>INT_FLAG</td><td>BUFFULL_FLAG</td><td></td><td></td><td>RESERVED</td><td></td><td></td></tr><tr><td>W1C-Oh</td><td>RC-Oh</td><td>R-Oh</td><td></td><td></td><td>R-Oh</td><td></td><td></td></tr></table>

Table 18-11. SPISTS Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-8</td><td>RESERVED</td><td>R</td><td>0h</td><td>Reserved</td></tr><tr><td>7</td><td>OVERRUN_FLAG</td><td>W1C</td><td>0h</td><td>SPI Receiver Overrun FlagThis bit is a read/clear-only flag. The SPI hardware sets this bit when a receive or transmit operation completes before the previous character has been read from the buffer. The bit is cleared in one of three ways:- Writing a 1 to this bit- Writing a 0 to SPI SW RESET (SPICCR.7)- Resetting the systemIf the OVERRUN INT ENA bit (SPICTL.4) is set, the SPI requests only one interrupt upon the first occurrence of setting the RECEIVER OVERRUN Flag bit. Subsequent overruns will not request additional interrupts if this flag bit is already set. This means that in order to allow new overrun interrupt requests the user must clear this flag bit by writing a 1 to SPISTS.7 each time an overrun condition occurs. In other words, if the RECEIVER OVERRUN Flag bit is left set (not cleared) by the interrupt service routine, another overrun interrupt will not be immediately re-entered when the interrupt service routine is exited-reset type: SYSRSn0h (R/W) = A receive overrun condition has not occurred.1h (R/W) = The last received character has been overwritten and therefore lost (when the SPIRXBUF was overwritten by the SPI module before the previous character was read by the user application).Writing a &#x27;1&#x27; will clear this bit. The RECEIVER OVERRUN Flag bit should be cleared during the interrupt service routine because the RECEIVER OVERRUN Flag bit and SPI INT FLAG bit (SPISTS.6) share the same interrupt vector. This will alleviate any possible doubt as to the source of the interrupt when the next byte is received.</td></tr></table>

Table 18-11. SPISTS Register Field Descriptions (continued)  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>6</td><td>INT_FLAG</td><td>RC</td><td>0h</td><td>SPI Interrupt Flag
SPI INT FLAG is a read-only flag. Hardware sets this bit to indicate that the SPI has completed sending or receiving the last bit and is ready to be serviced. This flag causes an interrupt to be requested if the SPI INT ENA bit (SPICTL.0) is set. The received character is placed in the receiver buffer at the same time this bit is set. This bit is cleared in one of three ways:
- Reading SPIRXBUF
- Writing a 0 to SPI SW RESET (SPICCR.7)
- Resetting the system
Note: This bit should not be used if FIFO mode is enabled. The internal process of copying the received word from SPIXBUF to the Receive FIFO will clear this bit. Use the FIFO status, or FIFO interrupt bits for similar functionality.
Reset type: SYSRSn
0h (R/W) = No full words have been received or transmitted.
1h (R/W) = Indicates that the SPI has completed sending or receiving the last bit and is ready to be serviced.</td></tr><tr><td>5</td><td>BUFFULL_FLAG</td><td>R</td><td>0h</td><td>SPI Transmit Buffer Full Flag
This read-only bit gets set to 1 when a character is written to the SPI Transmit buffer SPITXBUF. It is cleared when the character is automatically loaded into SPIDAT when the shifting out of a previous character is complete.
Reset type: SYSRSn
0h (R/W) = Transmit buffer is not full.
1h (R/W) = Transmit buffer is full.</td></tr><tr><td>4-0</td><td>RESERVED</td><td>R</td><td>0h</td><td>Reserved</td></tr></table>

# 18.5.2.4 SPIBRR Register (Offset = 4h) [reset = 0h]

SPIBRR is shown in Figure 18-17 and described in Table 18-12.

Return to the Summary Table.

SPIBRR contains the bits used for baud-rate selection.

Figure 18-17. SPIBRR Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td colspan="8">RESERVED</td></tr><tr><td colspan="8">R-Oh</td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>RESERVED</td><td colspan="7">SPI_BIT_RATE</td></tr><tr><td>R-Oh</td><td colspan="7">R/W-Oh</td></tr></table>

Table 18-12. SPIBRR Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-7</td><td>RESERVED</td><td>R</td><td>0h</td><td>Reserved</td></tr><tr><td>6-0</td><td>SPI_BIT_RATE</td><td>R/W</td><td>0h</td><td>SPI Baud Rate Control
These bits determine the bit transfer rate if the SPI is the network
SPI BIT RATE 0 master. There are 125 data-transfer rates (each a function of the CPU clock, LSPCLK) that can be selected. One data bit is shifted per SPICLK cycle. (SPICLK is the baud rate clock output on the SPICLK pin.)
If the SPI is a network slave, the module receives a clock on the SPICLK pin from the network master. Therefore, these bits have no effect on the SPICLK signal. The frequency of the input clock from the master should not exceed the slave SPI&#x27;s LSPCLK signal divided by 4.
In master mode, the SPI clock is generated by the SPI and is output on the SPICLK pin. The SPI baud rates are determined by the following formula:
For SIBRR = 3 to 127: SPI Baud Rate = LSPCLK / (SPIBRR + 1)
For SIBRR = 0, 1, or 2: SPI Baud Rate = LSPCLK / 4
Reset type: SYSRSn
3h (R/W) = SPI Baud Rate = LSPCLK/4
4h (R/W) = SPI Baud Rate = LSPCLK/5
7Eh (R/W) = SPI Baud Rate = LSPCLK/127
7Fh (R/W) = SPI Baud Rate = LSPCLK/128</td></tr></table>

# 18.5.2.5 SPIRXEMU Register (Offset = 6h) [reset = 0h]

SPIRXEMU is shown in Figure 18-18 and described in Table 18-13.

Return to the Summary Table.

SPIRXEMU contains the received data. Reading SPIRXEMU does not clear the SPI INT FLAG bit of SPISTS. This is not a real register but a dummy address from which the contents of SPIXBUF can be read by the emulator without clearing the SPI INT FLAG.

Figure 18-18. SPIRXEMU Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td></td><td></td><td></td><td>ERXBn</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>R-Oh</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td>ERXBn</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>R-Oh</td><td></td><td></td><td></td><td></td></tr></table>

Table 18-13. SPIRXEMU Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-0</td><td>ERXBn</td><td>R</td><td>Oh</td><td>Emulation Buffer Received Data
SPIRXEMU functions almost identically to SPIXBUF, except that reading SPIXEMU does not clear the SPI INT FLAG bit (SPISTS.6). Once the SPIDAT has received the complete character, the character is transferred to SPIXEMU and SPIXBUF, where it can be read. At the same time, SPI INT FLAG is set.
This mirror register was created to support emulation. Reading SPIXBUF clears the SPI INT FLAG bit (SPISTS.6). In the normal operation of the emulator, the control registers are read to continually update the contents of these registers on the display screen. SPIXEMU was created so that the emulator can read this register and properly update the contents on the display screen. Reading SPIXEMU does not clear the SPI INT FLAG bit, but reading SPIXBUF clears this flag. In other words, SPIXEMU enables the emulator to emulate the true operation of the SPI more accurately.
It is recommended that you view SPIXEMU in the normal emulator run mode.
Reset type: SYSRSn</td></tr></table>

# 18.5.2.6 SPIRXBUF Register (Offset = 7h) [reset = 0h]

SPIRXBUF is shown in Figure 18-19 and described in Table 18-14.

Return to the Summary Table.

SPIRXBUF contains the received data. Reading SPIRXBUF clears the SPI INT FLAG bit in SPISTS. If FIFO mode is enabled, reading this register will also decrement the RXFFST counter in SPIFFRX.

Figure 18-19. SPIRXBUF Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td></td><td></td><td></td><td>RXBn</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>R-Oh</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td>RXBn</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>R-Oh</td><td></td><td></td><td></td><td></td></tr></table>

Table 18-14. SPIRXBUF Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-0</td><td>RXBn</td><td>R</td><td>0h</td><td>Received Data
Once SPIDAT has received the complete character, the character is transferred to SPIXBUF, where it can be read. At the same time, the SPI INT FLAG bit (SPISTS.6) is set. Since data is shifted into the SPI&#x27;s most significant bit first, it is stored right-justified in this register.
Reset type: SYSRSn</td></tr></table>

# 18.5.2.7 SPITXBUF Register (Offset = 8h) [reset = 0h]

SPITXBUF is shown in Figure 18-20 and described in Table 18-15.

Return to the Summary Table.

SPITXBUF stores the next character to be transmitted. Writing to this register sets the TX BUF FULL Flag bit in SPISTS. When the transmission of the current character is complete, the contents of this register are automatically loaded in SPIDAT and the TX BUF FULL Flag is cleared. If no transmission is currently active, data written to this register falls through into the SPIDAT register and the TX BUF FULL Flag is not set.

In master mode, if no transmission is currently active, writing to this register initiates a transmission in the same manner that writing to SPIDAT does.

Figure 18-20. SPITXBUF Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td></td><td></td><td></td><td>TXBn</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>R/W-Oh</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td>TXBn</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>R/W-Oh</td><td></td><td></td><td></td><td></td></tr></table>

Table 18-15. SPITXBUF Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-0</td><td>TXBn</td><td>R/W</td><td>0h</td><td>Transmit Data BufferThis is where the next character to be transmitted is stored. When the transmission of the current character has completed, if the TX BUF FULL Flag bit is set, the contents of this register is automatically transferred to SPIDAT, and the TX BUF FULL Flag is cleared. Writes to SPITXBUF must be left-justified. Reset type: SYSRSn</td></tr></table>

# 18.5.2.8 SPIDAT Register (Offset = 9h) [reset = 0h]

SPIDAT is shown in Figure 18-21 and described in Table 18-16.

Return to the Summary Table.

SPIDAT is the transmit and receive shift register. Data written to SPIDAT is shifted out (MSB) on subsequent SPICLK cycles. For every bit (MSB) shifted out of the SPI, a bit is shifted into the LSB end of the shift register.

Figure 18-21. SPIDAT Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td></td><td></td><td></td><td>SDATn</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>R/W-Oh</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td>SDATn</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>R/W-Oh</td><td></td><td></td><td></td><td></td></tr></table>

Table 18-16. SPIDAT Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-0</td><td>SDATn</td><td>R/W</td><td>Oh</td><td>Serial Data Shift Register
- It provides data to be output on the serial output pin if the TALK bit (SPICTL.1) is set.
- When the SPI is operating as a master, a data transfer is initiated. When initiating a transfer, check the CLOCK POLARITY bit (SPICCR.6) described in Section 10.2.1.1 and the CLOCK PHASE bit (SPICTL.3) described in Section 10.2.1.2, for the requirements.
In master mode, writing dummy data to SPIDAT initiates a receive sequence. Since the data is not hardware-justified for characters shorter than sixteen bits, transmit data must be written in left-justified form, and received data read in right-justified form.
Reset type: SYSRSn</td></tr></table>

# 18.5.2.9 SPIFFTX Register (Offset = Ah) [reset = A000h]

SPIFFTX is shown in Figure 18-22 and described in Table 18-17.

Return to the Summary Table.

SPIFFTX contains both control and status bits related to the output FIFO buffer. This includes FIFO reset control, FIFO interrupt level control, FIFO level status, as well as FIFO interrupt enable and clear bits.

Figure 18-22. SPIFFTX Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td>SPIRST</td><td>SPIFFENA</td><td>TXFIFO</td><td></td><td></td><td>TXFFST</td><td></td><td></td></tr><tr><td>R/W-1h</td><td>R/W-0h</td><td>R/W-1h</td><td></td><td></td><td>R-Oh</td><td></td><td></td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>TXFFINT</td><td>TXFFINTCLR</td><td>TXFFIENA</td><td></td><td></td><td>TXFFIL</td><td></td><td></td></tr><tr><td>R-Oh</td><td>W-Oh</td><td>R/W-Oh</td><td></td><td></td><td>R/W-Oh</td><td></td><td></td></tr></table>

Table 18-17. SPIFFTX Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15</td><td>SPIRST</td><td>R/W</td><td>1h</td><td>SPI ResetReset type: SYSRSn0h (R/W) = Write 0 to reset the SPI transmit and receive channels. The SPI FIFO register configuration bits will be left as is.1h (R/W) = SPI FIFO can resume transmit or receive. No effect to the SPI registers bits.</td></tr><tr><td>14</td><td>SPIFFENA</td><td>R/W</td><td>0h</td><td>SPI FIFO Enhancements EnableReset type: SYSRSn0h (R/W) = SPI FIFO enhancements are disabled.1h (R/W) = SPI FIFO enhancements are enabled.</td></tr><tr><td>13</td><td>TXFIFO</td><td>R/W</td><td>1h</td><td>TX FIFO ResetReset type: SYSRSn0h (R/W) = Write 0 to reset the FIFO pointer to zero, and hold inreset.1h (R/W) = Release transmit FIFO from reset.</td></tr><tr><td>12-8</td><td>TXFFST</td><td>R</td><td>0h</td><td>Transmit FIFO StatusReset type: SYSRSn0h (R/W) = Transmit FIFO is empty.1h (R/W) = Transmit FIFO has 1 word.2h (R/W) = Transmit FIFO has 2 words.10h (R/W) = Transmit FIFO has 16 words, which is the maximum.1Fh (R/W) = Reserved.</td></tr><tr><td>7</td><td>TXFFINT</td><td>R</td><td>0h</td><td>TX FIFO Interrupt FlagReset type: SYSRSn0h (R/W) = TXFIFO interrupt has not occurred, This is a read-only bit.1h (R/W) = TXFIFO interrupt has occurred, This is a read-only bit.</td></tr><tr><td>6</td><td>TXFFINTCLR</td><td>W</td><td>0h</td><td>TXFIFO Interrupt ClearReset type: SYSRSn0h (R/W) = Write 0 has no effect on TXFIFINT flag bit, Bit reads back a zero.1h (R/W) = Write 1 to clear SPIFFTX[TXFFINT] flag.</td></tr><tr><td>5</td><td>TXFFIENA</td><td>R/W</td><td>0h</td><td>TX FIFO Interrupt EnableReset type: SYSRSn0h (R/W) = TX FIFO interrupt based on TXFFIL match (less than or equal to) will be disabled.1h (R/W) = TX FIFO interrupt based on TXFFIL match (less than or equal to) will be enabled.</td></tr></table>

Table 18-17. SPIFTX Register Field Descriptions (continued)  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>4-0</td><td>TXFFIL</td><td>R/W</td><td>0h</td><td>Transmit FIFO Interrupt Level BitsTransmit FIFO will generate interrupt when the FIFO status bits (TXFFST4-0) and FIFO level bits (TXFFIL4-0) match (less than or equal to).Reset type: SYSRSN0h (R/W) = A TX FIFO interrupt request is generated when there are no words remaining in the TX buffer.1h (R/W) = A TX FIFO interrupt request is generated when there is 1 word or no words remaining in the TX buffer.2h (R/W) = A TX FIFO interrupt request is generated when there is 2 words or fewer remaining in the TX buffer.10h (R/W) = A TX FIFO interrupt request is generated when there are 16 words or fewer remaining in the TX buffer.1Fh (R/W) = Reserved.</td></tr></table>

# 18.5.2.10 SPIFFRX Register (Offset = Bh) [reset = 201Fh]

SPIFFRX is shown in Figure 18-23 and described in Table 18-18.

Return to the Summary Table.

SPIFFRX contains both control and status bits related to the input FIFO buffer. This includes FIFO reset control, FIFO interrupt level control, FIFO level status, as well as FIFO interrupt enable and clear bits.

Figure 18-23. SPIFFRX Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td>RXFFOVF</td><td>RXFFOVFCLR</td><td>RXFIFORESET</td><td></td><td></td><td>RXFFST</td><td></td><td></td></tr><tr><td>R-Oh</td><td>W-Oh</td><td>R/W-1h</td><td></td><td></td><td>R-Oh</td><td></td><td></td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>RXFFINT</td><td>RXFFINTCLR</td><td>RXFFIENA</td><td></td><td></td><td>RXFFIL</td><td></td><td></td></tr><tr><td>R-Oh</td><td>W-Oh</td><td>R/W-Oh</td><td></td><td></td><td>R/W-1Fh</td><td></td><td></td></tr></table>

Table 18-18. SPIFFRX Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15</td><td>RXFFOVF</td><td>R</td><td>0h</td><td>Receive FIFO Overflow FlagReset type: SYSRSnOh (R/W) = Receive FIFO has not overflowed. This is a read-only bit.1h (R/W) = Receive FIFO has overflowed, read-only bit. More than 16 words have been received in to the FIFO, and the first received word is lost.</td></tr><tr><td>14</td><td>RXFFOVFCLR</td><td>W</td><td>0h</td><td>Receive FIFO Overflow ClearReset type: SYSRSnOh (R/W) = Write 0 does not affect RXFFOVF flag bit, Bit reads back a zero.1h (R/W) = Write 1 to clear SPIFFRX[RXFFOVF].</td></tr><tr><td>13</td><td>RXFIFORESET</td><td>R/W</td><td>1h</td><td>Receive FIFO ResetReset type: SYSRSnOh (R/W) = Write 0 to reset the FIFO pointer to zero, and hold in reset.1h (R/W) = Re-enable receive FIFO operation.</td></tr><tr><td>12-8</td><td>RXFFST</td><td>R</td><td>0h</td><td>Receive FIFO StatusReset type: SYSRSnOh (R/W) = Receive FIFO is empty.1h (R/W) = Receive FIFO has 1 word.2h (R/W) = Receive FIFO has 2 words.10h (R/W) = Receive FIFO has 16 words, which is the maximum.1Fh (R/W) = Reserved.</td></tr><tr><td>7</td><td>RXFFINT</td><td>R</td><td>0h</td><td>Receive FIFO Interrupt FlagReset type: SYSRSnOh (R/W) = RXFIFO interrupt has not occurred. This is a read-only bit.1h (R/W) = RXFIFO interrupt has occurred. This is a read-only bit.</td></tr><tr><td>6</td><td>RXFFINTCLR</td><td>W</td><td>0h</td><td>Receive FIFO Interrupt ClearReset type: SYSRSnOh (R/W) = Write 0 has no effect on RXFIFINT flag bit, Bit reads back a zero.1h (R/W) = Write 1 to clear SPIFFRX[RXFFINT] flag</td></tr></table>

Table 18-18. SPIFFRX Register Field Descriptions (continued)  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>5</td><td>RXFFIENA</td><td>R/W</td><td>0h</td><td>RX FIFO Interrupt EnableReset type: SYSRSn0h (R/W) = RX FIFO interrupt based on RXFFIL match (greater than or equal to) will be disabled.1h (R/W) = RX FIFO interrupt based on RXFFIL match (greater than or equal to) will be enabled.</td></tr><tr><td>4-0</td><td>RXFFIL</td><td>R/W</td><td>1Fh</td><td>Receive FIFO Interrupt Level BitsReceive FIFO generates an interrupt when the FIFO status bits (RXFFST4-0) are greater than or equal to the FIFO level bits (RXFFIL4-0). The default value of these bits after reset is 11111. This avoids frequent interrupts after reset, as the receive FIFO will be empty most of the time.Reset type: SYSRSN0h (R/W) = A RX FIFO interrupt request is generated when there is 0 or more words in the RX buffer.1h (R/W) = A RX FIFO interrupt request is generated when there are 1 or more words in the RX buffer.2h (R/W) = A RX FIFO interrupt request is generated when there are 2 or more words in the RX buffer.10h (R/W) = A RX FIFO interrupt request is generated when there are 16 words in the RX buffer.1Fh (R/W) = Reserved.</td></tr></table>

# 18.5.2.11 SPIFFCT Register (Offset = Ch) [reset = 0h]

SPIFFCT is shown in Figure 18-24 and described in Table 18-19.

Return to the Summary Table.

SPIFFCT controls the FIFO transmit delay bits.

Figure 18-24. SPIFFCT Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>

Table 18-19. SPIFFCT Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-8</td><td>RESERVED</td><td>R</td><td>0h</td><td>Reserved</td></tr><tr><td>7-0</td><td>TXDLY</td><td>R/W</td><td>0h</td><td>FIFO Transmit Delay BitsThese bits define the delay between every transfer from FIFO transmit buffer to transmit shift register. The delay is defined in number SPI serial clock cycles. The 8-bit register could define a minimum delay of 0 serial clock cycles and a maximum of 255 serial clock cycles. In FIFO mode, the buffer (TXBUF) between the shift register and the FIFO should be filled only after the shift register has completed shifting of the last bit. This is required to pass on the delay between transfers to the data stream. In the FIFO mode TXBUF should not be treated as one additional level of buffer. Reset type: SYSRSN0h (R/W) = The next word in the TX FIFO buffer is transferred to SPITXBUF immediately upon completion of transmission of the previous word.1h (R/W) = The next word in the TX FIFO buffer is transferred to SPITXBUF1 serial clock cycle after completion of transmission of the previous word.2h (R/W) = The next word in the TX FIFO buffer is transferred to SPITXBUF 2 serial clock cycles after completion of transmission of the previous word.FFh (R/W) = The next word in the TX FIFO buffer is transferred to SPITXBUF 255 serial clock cycles after completion of transmission of the previous word.</td></tr></table>

# 18.5.2.12 SPIRl Register (Offset = Fh) [reset = 0h]

SPIPI is shown in Figure 18-25 and described in Table 18-20.

Return to the Summary Table.

SPIPI controls auxiliary functions for the SPI including emulation control, SPISTE inversion, and 3-wire control.

Figure 18-25. SPIPRI Register  

<table><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td></tr><tr><td colspan="8">RESERVED</td></tr><tr><td colspan="8">R-Oh</td></tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>RESERVED</td><td>RESERVED</td><td>SOFT</td><td>FREE</td><td colspan="2">RESERVED</td><td>STEINV</td><td>TRIWIRE</td></tr><tr><td>R-Oh</td><td colspan="2">R/W-Oh</td><td>R/W-Oh</td><td colspan="2">R-Oh</td><td>R/W-Oh</td><td>R/W-Oh</td></tr></table>

Table 18-20. SPIRl Register Field Descriptions  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>15-7</td><td>RESERVED</td><td>R</td><td>0h</td><td>Reserved</td></tr><tr><td>6</td><td>RESERVED</td><td>R/W</td><td>0h</td><td>Reserved</td></tr><tr><td>5</td><td>SOFT</td><td>R/W</td><td>0h</td><td>Emulation Soft RunThis bit only has an effect when the FREE bit is 0.Reset type: SYSRSNOh (R/W) = Transmission stops midway in the bit stream whileTSUSPEND is asserted. Once TSUSPEND is deasserted without asystem reset, the remainder of the bits pending in the DATBUF areshifted. Example: If SPIDAT has shifted 3 out of 8 bits, thecommunication freezes right there. However, if TSUSPEND is laterdeasserted without resetting the SPI, SPI starts transmitting fromwhere it had stopped (fourth bit in this case) and will transmit 8 bitsfrom that point.1h (R/W) = If the emulation suspend occurs before the start of atransmission, (that is, before the first SPICLK pulse) then thetransmission will not occur. If the emulation suspend occurs afterthe start of a transmission, then the data will be shifted out tocompletion. When the start of transmission occurs is dependent onthe baud rate used.Standard SPI mode: Stop after transmitting the words in the shiftregister and buffer. That is, after TXBUF and SPIDAT are empty.In FIFO mode: Stop after transmitting the words in the shift registerand buffer. That is, after TX FIFO and SPIDAT are empty.</td></tr><tr><td>4</td><td>FREE</td><td>R/W</td><td>0h</td><td>Emulation Free RunThese bits determine what occurs when an emulation suspendoccurs (for example, when the debugger hits a breakpoint). Theperipheral can continue whatever it is doing (free-run mode) or, if instop mode, it can either stop immediately or stop when the currentoperation (the current receive/transmit sequence) is complete Reset type: SYSRSNOh (R/W) = Emulation mode is selected by the SOFT bit1h (R/W) = Free run, continue SPI operation regardless of suspendor when the suspend occurred.</td></tr><tr><td>3-2</td><td>RESERVED</td><td>R</td><td>0h</td><td>Reserved</td></tr></table>

Table 18-20. SPIRRegister Field Descriptions (continued)  

<table><tr><td>Bit</td><td>Field</td><td>Type</td><td>Reset</td><td>Description</td></tr><tr><td>1</td><td>STEINV</td><td>R/W</td><td>0h</td><td>SPISTEn Inversion Bit
On devices with 2 SPI modules, inverting the SPISTE signal on one of the modules allows the device to receive left and right- channel digital audio data.
This bit is only applicable to slave mode. Writing to this bit while configured as master (MASTER_SLAVE = 1) has no effect
Reset type: SYSRSn
0h (R/W) = SPISTEn is active low (normal)
1h (R/W) = SPISTE is active high (inverted)</td></tr><tr><td>0</td><td>TRIWIRE</td><td>R/W</td><td>0h</td><td>SPI 3-wire Mode Enable
Reset type: SYSRSn
0h (R/W) = Normal 4-wire SPI mode.
1h (R/W) = 3-wire SPI mode enabled. The unused pin becomes a GPIO pin. In master mode, the SPISIMO pin becomes the SPIOMI (master receive and transmit) pin and SPIOMI is free for non-SPI use. In slave mode, the SPIOMI pin becomes the SPIISIO (slave receive and transmit) pin and SPISIMO is free for non-SPI use.</td></tr></table>

# 18.5.3 Register to Driverlib Function Mapping

Table 18-21. SPI Registers to Driverlib Functions  

<table><tr><td>File</td><td>Driverlib Function</td></tr><tr><td colspan="2">CCR</td></tr><tr><td>spi.c</td><td>SPI_setConfig</td></tr><tr><td>spi.c</td><td>SPI_clearInterruptStatus</td></tr><tr><td>spi.h</td><td>SPI_enableModule</td></tr><tr><td>spi.h</td><td>SPI_disableModule</td></tr><tr><td>spi.h</td><td>SPI_enableLoopback</td></tr><tr><td>spi.h</td><td>SPI_disableLoopback</td></tr><tr><td>spi.h</td><td>SPI_enableHighSpeedMode</td></tr><tr><td>spi.h</td><td>SPI_disableHighSpeedMode</td></tr><tr><td colspan="2">CTL</td></tr><tr><td>spi.c</td><td>SPI_setConfig</td></tr><tr><td>spi.c</td><td>SPI_enableInterrupt</td></tr><tr><td>spi.c</td><td>SPI_disableInterrupt</td></tr><tr><td>spi.h</td><td>SPI_enableTalk</td></tr><tr><td>spi.h</td><td>SPI_disableTalk</td></tr><tr><td colspan="2">STS</td></tr><tr><td>spi.c</td><td>SPI_getInterruptStatus</td></tr><tr><td>spi.c</td><td>SPI_getInterruptStatus</td></tr><tr><td>spi.h</td><td>SPI_writeDataBlockingNonFIFO</td></tr><tr><td>spi.h</td><td>SPI_readDataBlockingNonFIFO</td></tr><tr><td colspan="2">BRR</td></tr><tr><td>spi.c</td><td>SPI_setConfig</td></tr><tr><td>spi.c</td><td>SPI_setBaudRate</td></tr><tr><td colspan="2">RXEMU</td></tr><tr><td>spi.h</td><td>SPI_readRxEmulationBuffer</td></tr><tr><td colspan="2">RXBUF</td></tr><tr><td>spi.h</td><td>SPI_readDataNonBlocking</td></tr><tr><td>spi.h</td><td>SPI_readDataBlockingFIFO</td></tr><tr><td>spi.h</td><td>SPI_readDataBlockingNonFIFO</td></tr><tr><td colspan="2">TXBUF</td></tr><tr><td>spi.h</td><td>SPI_writeDataNonBlocking</td></tr><tr><td>spi.h</td><td>SPI_writeDataBlockingFIFO</td></tr><tr><td>spi.h</td><td>SPI_writeDataBlockingNonFIFO</td></tr><tr><td colspan="2">FFTX</td></tr><tr><td>spi.c</td><td>SPI_enableInterrupt</td></tr><tr><td>spi.c</td><td>SPI_disableInterrupt</td></tr><tr><td>spi.c</td><td>SPI_getInterruptStatus</td></tr><tr><td>spi.c</td><td>SPI_clearInterruptStatus</td></tr><tr><td>spi.h</td><td>SPI_enableFIFO</td></tr><tr><td>spi.h</td><td>SPI_disableFIFO</td></tr><tr><td>spi.h</td><td>SPI_resetTxFIFO</td></tr><tr><td>spi.h</td><td>SPI_setFIFOInterruptLevel</td></tr><tr><td>spi.h</td><td>SPI_getFIFOInterruptLevel</td></tr><tr><td>spi.h</td><td>SPI_getTxFIFOStatus</td></tr><tr><td>spi.h</td><td>SPI_isBusy</td></tr></table>

Table 18-21. SPI Registers to Driverlib Functions (continued)  

<table><tr><td>File</td><td>Driverlib Function</td></tr><tr><td colspan="2">FFRX</td></tr><tr><td>spi.c</td><td>SPI_enableInterrupt</td></tr><tr><td>spi.c</td><td>SPI_disableInterrupt</td></tr><tr><td>spi.c</td><td>SPI_getInterruptStatus</td></tr><tr><td>spi.c</td><td>SPI_clearInterruptStatus</td></tr><tr><td>spi.h</td><td>SPI_enableFIFO</td></tr><tr><td>spi.h</td><td>SPI_disableFIFO</td></tr><tr><td>spi.h</td><td>SPI_resetRxFIFO</td></tr><tr><td>spi.h</td><td>SPI_setFIFOInterruptLevel</td></tr><tr><td>spi.h</td><td>SPI_getFIFOInterruptLevel</td></tr><tr><td>spi.h</td><td>SPI_getRxFIFOStatus</td></tr><tr><td colspan="2">FFCT</td></tr><tr><td>spi.h</td><td>SPI_setTxFifoTransmitDelay</td></tr><tr><td colspan="2">PRI</td></tr><tr><td>spi.h</td><td>SPI_enableTriWire</td></tr><tr><td>spi.h</td><td>SPI_disableTriWire</td></tr><tr><td>spi.h</td><td>SPI_setSTESignalPolarity</td></tr><tr><td>spi.h</td><td>SPI_setEmulationMode</td></tr></table>