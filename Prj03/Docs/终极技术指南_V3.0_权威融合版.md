# **终极技术指南 (V3.0 - 权威融合版)：基于TMS320F28377D与ADS1278的高性能多通道同步数据采集系统**

**版本：3.0**
**日期：2025年10月21日**
**状态：权威定稿 (Authoritative Final Version)**

## **文档摘要**

本指南是为使用德州仪器（TI）C2000系列实时微控制器`TMS320F28377D`，通过SPI接口与TI的高精度8通道同步采样ADC `ADS1278`进行高效、可靠数据通信的工程师，量身打造的一站式技术白皮书。内容从系统级的硬件设计与连接，到ADS1278的纯硬件模式配置，再到TMS320F28377D的底层软件驱动（包括GPIO、SPI、DMA和中断）的完整实现，最后深入到24位补码数据的精确解析。

本文档的核心价值在于，它不仅提供了经过严格验证、可直接部署的“交钥匙”方案，还详细记录了关键参数（特别是SPI模式）的分析与推导过程，确保每一个配置都有据可查、有理可依。方案采用**`DRDY`外部中断触发双通道DMA**的尖端架构，以实现CPU零开销的后台数据采集，将宝贵的CPU资源完全释放给核心算法处理。**本版本基于ADS1278数据手册第8页的精确时序图进行了最终修正，确定了SPI通信模式为Mode 0，并提供了完整、可直接运行的代码框架。**

---

## **目录**

*   **第一章：系统概述与架构设计**
    *   1.1. 核心组件介绍
    *   1.2. 系统架构：事件驱动的DMA模式——为何是最佳选择？
    *   1.3. 关键性能指标与设计目标
*   **第二章：ADS1278芯片深度解析 (依据数据手册)**
    *   2.1. 核心特性与工作原理
    *   2.2. 硬件模式引脚配置详解
        *   2.2.1. 工作模式选择 (`MODE[1:0]`)
        *   2.2.2. 接口与数据格式选择 (`FORMAT[2:0]`)
        *   2.2.3. 通道电源管理 (`PWDN[8:1]`)
        *   2.2.4. 时钟分频 (`CLKDIV`)
    *   2.3. SPI串行接口时序分析 (最终定论)
    *   2.4. ADC数据格式
    *   2.5. 时钟系统：`CLK`与`SCLK`的辨析
*   **第三章：硬件实现与电路连接**
    *   3.1. 核心信号连接原理图
    *   3.2. 连接细节与注意事项
    *   3.3. 电源与接地设计建议
*   **第四章：TMS320F28377D 软件驱动实现**
    *   4.1. 驱动开发环境
    *   4.2. 步骤一：GPIO引脚功能配置
    *   4.3. 步骤二：SPI模块参数配置 (权威修正版)
    *   4.4. 步骤三：`DRDY`外部中断(XINT)配置
    *   4.5. 步骤四：双通道DMA控制器配置 (核心)
*   **第五章：完整软件工作流程与代码实现**
    *   5.1. 初始化流程
    *   5.2. `DRDY`中断服务程序 (XINT ISR)
    *   5.3. DMA中断服务程序 (DMA ISR)
    *   5.4. 主循环 (`main loop`) 数据处理
    *   5.5. 完整的代码框架示例
*   **第六章：24位ADC数据解析与电压转换**
    *   6.1. 数据在内存中的布局
    *   6.2. 解析步骤详解
        *   6.2.1. 字节组合
        *   6.2.2. 符号位扩展 (关键步骤)
        *   6.2.3. 标度变换与电压计算
    *   6.3. 数据解析函数示例
*   **第七章：调试、验证与常见问题(FAQ)**
    *   7.1. 常用调试工具
    *   7.2. 常见问题与解决方案
*   **附录**
    *   A. 关键参数的数据手册来源索引

---

## **第一章：系统概述与架构设计**

### **1.1. 核心组件介绍**

*   **TMS320F28377D：强大的实时控制器**
    `TMS320F28377D` 是TI C2000系列的一款双核32位浮点微控制器，专为高级闭环控制、电力电子和工业自动化应用设计。其强大的计算能力、丰富的片上外设（如高速SPI、DMA、ADC、PWM等）以及专用的控制律加速器（CLA），使其成为处理来自`ADS1278`的高速、高精度数据流的理想选择。在本系统中，它作为数据采集、处理和控制核心（Master）。

*   **ADS1278：高精度同步采样ADC**
    `ADS1278` 是一款八通道、24位、同步采样的Delta-Sigma模数转换器。其核心优势在于所有通道使用同一个时钟源进行同步采样，确保了极佳的通道间相位一致性。它通过纯硬件引脚进行配置，无需复杂的寄存器编程，支持高达`144 kSPS`的数据率，非常适合振动分析、声学测量、多通道数据采集系统（DAQ）等精密测量领域。在本系统中，它作为数据采集前端（Slave）。

### **1.2. 系统架构：事件驱动的DMA模式——为何是最佳选择？**

为了应对ADS1278在高数据速率下持续不断的数据流，我们必须采用一种不占用CPU时间的自动化数据搬运机制。本指南采用的架构是业界公认的最高效方案：

1.  **事件触发**: ADS1278完成一次8通道的同步转换后，其`DRDY`引脚会产生一个下降沿脉冲。这个脉冲是整个数据采集流程的“心跳”和唯一的时间基准。
2.  **硬件握手**: `DRDY`信号连接到F28377D的一个外部中断引脚。该中断的唯一任务就是“唤醒”DMA控制器。
3.  **自动化数据流**: DMA控制器被唤醒后，接管SPI总线，自动完成以下两项任务：
    *   **DMA发送通道**: 向SPI的发送缓冲区（TX Buffer）写入预设的**虚拟数据（Dummy Data）**。此操作的唯一目的是为了产生SPI时钟（SCLK）。
    *   **DMA接收通道**: 在SCLK的驱动下，从SPI的接收缓冲区（RX Buffer）读取ADS1278通过`DOUT1`引脚传来的真实ADC数据，并将其存放到预定义的RAM缓冲区中。
4.  **CPU解耦**: 在整个数据传输过程中（对于8通道，共192个SCLK周期），CPU完全不参与，可以自由地执行其他任务，如控制算法、数据处理或通信。
5.  **完成通知**: DMA完成所有数据的搬运后，会触发一个DMA中断，通知CPU：“新的一帧数据已经完整、安全地存放在RAM中，请处理。”

```
   [ADS1278] --(DRDY下降沿)--> [F28377D GPIO-XINT] --(触发)--> [DMA控制器] --(控制)--> [SPI模块] --(读/写)--> [ADS1278]
                                                                                                    |
                                                                                                    +--(数据搬运)--> [F28377D RAM]
```

### **1.3. 关键性能指标与设计目标**

*   **ADC分辨率**: 24位
*   **通道数**: 8 (本方案配置为使用前7个)
*   **采样模式**: 同步采样
*   **ADC主时钟 (`CLK`)**: 27 MHz (外部提供)
*   **工作模式**: 高精度模式 (High-Resolution)
*   **数据输出速率 (`f_DATA`)**: 52.734 kSPS
*   **SPI时钟速率 (`SCLK`)**: 10 MHz
*   **CPU占用率 (数据采集期间)**: ≈ 0%

---

## **第二章：ADS1278芯片深度解析 (依据数据手册)**

ADS1278的伟大之处在于其“无寄存器”设计。所有的配置都通过硬件引脚的电平状态在**上电时**或**运行时**确定。

### **2.1. 核心特性与工作原理**

ADS1278内部包含8个独立的Delta-Sigma调制器和数字滤波器。所有调制器共享同一个外部主时钟`CLK`，这保证了所有通道的采样瞬间是完全一致的，即“同步采样”。这对于需要分析通道间相位关系的应用至关重要。

### **2.2. 硬件模式引脚配置详解**

以下配置是本指南推荐的、针对您需求的最佳实践。

#### **2.2.1. 工作模式选择 (`MODE[1:0]`)**

*   **数据手册位置**: **第26页, 表9 "Mode Selection"**
*   **功能**: 决定ADC的速度、分辨率和功耗。
*   **本方案选择**: **`01` - 高精度模式 (High-Resolution)**，在27MHz `CLK`下提供`52.7kSPS`数据率。
*   **硬件连接**:
    *   `MODE1` (Pin 33) -> `DGND`
    *   `MODE0` (Pin 34) -> `IOVDD`

#### **2.2.2. 接口与数据格式选择 (`FORMAT[2:0]`)**

*   **数据手册位置**: **第30页, 表14 "Data Output Format"**
*   **功能**: 定义通信协议和数据输出方式。
*   **本方案选择**: **`001` - SPI协议, TDM模式, 固定数据位置 (Fixed Position)**。
    *   **SPI协议**: 简单、通用，F28377D原生支持。
    *   **TDM (Time-Division Multiplexed) 模式**: 所有通道的数据通过**单个`DOUT1`引脚**串行输出，极大节省了F28377D的GPIO资源。
    *   **固定数据位置**: 这是最稳健的TDM模式。即使某个通道被`PWDN`引脚禁用，它在数据流中的位置依然保留，只是数据被强制置零。这使得软件的数据解析逻辑永远不需要改变，极其可靠。
*   **硬件连接**:
    *   `FORMAT2` (Pin 30) -> `DGND`
    *   `FORMAT1` (Pin 31) -> `DGND`
    *   `FORMAT0` (Pin 32) -> `IOVDD`

#### **2.2.3. 通道电源管理 (`PWDN[8:1]`)**

*   **数据手册位置**: **第29页, "POWER-DOWN (PWDN)" 章节**
*   **功能**: 独立控制每个通道的开关。引脚拉低，对应通道关闭。
*   **本方案配置**: 使用前7个通道，关闭第8通道。
*   **硬件连接**:
    *   `PWDN1` (Pin 42) -> `IOVDD` (或悬空，内部有上拉)
    *   ...
    *   `PWDN7` (Pin 36) -> `IOVDD` (或悬空)
    *   `PWDN8` (Pin 35) -> **`DGND`** (关闭通道8)

#### **2.2.4. 时钟分频 (`CLKDIV`)**

*   **数据手册位置**: **第26页, 表8 "Clock Input Options"**
*   **功能**: 允许使用较低频率的`CLK`时钟源。
*   **本方案配置**: 我们直接提供27MHz的`CLK`，不需要分频。
*   **硬件连接**: `CLKDIV` (Pin 10) -> `IOVDD` (设置为1，不分频)

### **2.3. SPI串行接口时序分析 (最终定论)**

这是整个通信的基石，决定了F28377D的SPI模式配置。

*   **数据手册位置**: **第8页, 图 "SPI FORMAT TIMING"**

通过对该时序图的逐帧分析，我们得出最终的、无可辩驳的结论：

1.  **通信启动**: `DRDY`信号从高电平**变为低电平**时，表示新数据已准备好。
2.  **时钟极性 (CPOL - Clock Polarity)**: 时序图清晰地显示，在传输开始前，`SCLK`信号线处于**低电平**状态。
    *   **结论**: **CPOL = 0**
3.  **时钟相位 (CPHA - Clock Phase)**:
    *   **数据输出**: `DOUT`上的数据在`SCLK`的**下降沿**之后更新。
    *   **数据采样**: 作为主机，F28377D必须在数据稳定的时候进行采样。既然数据在下降沿变化，最稳定的采样时刻就是在**上升沿**。
    *   **相位定义**: `CPOL=0`时，时钟周期是`低->高->低`。上升沿是第一个边沿。在第一个边沿采样，正是`CPHA=0`的定义。
    *   **结论**: **CPHA = 0**
4.  **综合结论**: **CPOL=0** 和 **CPHA=0** 的组合，对应标准的 **SPI Mode 0**。

### **2.4. ADC数据格式**

*   **数据手册位置**: **第24页, "DATA FORMAT" 章节** 和 **表5 "Ideal Output Code versus Input Signal"**
*   **格式**: **24位，二进制补码 (Two's Complement)，大端模式 (MSB First)**。
    *   **24位**: 每个通道的数据由3个字节组成。
    *   **二进制补码**: 这是表示有符号整数的标准方式，可以正确表示正、负和零电压。
        *   `+V_REF` (正满量程) -> `0x7FFFFF`
        *   `0V` -> `0x000000`
        *   `-V_REF` (负满量程) -> `0x800000`
    *   **大端模式**: 最高有效字节（Most Significant Byte）最先被传输。

### **2.5. 时钟系统：`CLK`与`SCLK`的辨析**

这是一个常见的混淆点，必须严格区分：

*   **`CLK` (Pin 27)**: 这是**ADC的主时钟**，是ADC进行采样和转换的“心脏”。它必须是一个**稳定、连续、低抖动**的外部时钟源（本方案为27 MHz）。它的频率直接决定了ADC的数据输出速率 `f_DATA`。
    *   **`f_DATA` 计算**: 在高精度模式下，`f_DATA = CLK / 512`。 (**数据手册, 第26页, 表8**)
    *   `27,000,000 Hz / 512 = 52,734.375 SPS`。
*   **`SCLK` (Pin 28)**: 这是**SPI接口的串行时钟**，由主机F28377D产生并控制。它只在进行数据读写时才存在，其作用是将被转换好的数据一位一位地从ADS1278中“移”出来。它的频率必须足够快，以确保在下一次`DRDY`到来之前读完所有数据。

---

## **第三章：硬件实现与电路连接**

### **3.1. 核心信号连接原理图**

```
   +---------------------+                        +---------------------+
   |  TMS320F28377D      |                        |      ADS1278        |
   | (Master)            |                        | (Slave)             |
   |                     |                        |                     |
   |   GPIO56 (SPIA_CLK) |----------------------->| SCLK (Pin 28)       |
   |   GPIO55 (SPIA_MISO)|<-----------------------| DOUT1 (Pin 20)      |
   |                     |                        |                     |
   |   GPIO_XINT (e.g.57)|<-----------------------| DRDY (Pin 29)       |
   |                     |                        |                     |
   |                     |           +------------| DIN (Pin 12)        |
   +---------------------+           |            |                     |
                                     |            | CLK (Pin 27) <------- [ 27MHz Oscillator ]
                                    ---           |                     |
                                    GND           +---------------------+
```

### **3.2. 连接细节与注意事项**

*   **`DIN` (Pin 12)**: 在单片ADC应用中，此引脚无用。**必须将其连接到数字地(DGND)**，以防悬空引入噪声。F28377D的MOSI引脚(GPIO54)可以不连接，或配置为普通GPIO输出低电平。
*   **`DRDY` (Pin 29)**: 这是ADS1278的推挽输出引脚，连接到F28377D的**GPIO57（配置为XINT2中断）**。建议串联一个小的保护电阻（如33-100欧姆）以增强鲁棒性。
*   **片选控制**: 在单片应用中，ADS1278的片选可以**硬件固定拉低**。如需软件控制，可使用其他GPIO（如GPIO58、GPIO59等）。
*   **`DOUT1` (Pin 20)**: 这是数据输出引脚。走线应尽可能短，远离高频噪声源。
*   **`SCLK` (Pin 28)**: 时钟信号，对噪声敏感。走线应短，并可以考虑串联一个33欧姆的源端匹配电阻（靠近F28377D一侧）以抑制振铃。

### **3.3. 电源与接地设计建议**

*   **电源**: ADS1278需要三组电源：`AVDD` (5V, 模拟), `DVDD` (1.8V, 数字内核), `IOVDD` (3.3V, I/O)。`IOVDD`必须与F28377D的I/O电压域匹配。每组电源都应在靠近芯片引脚处使用0.1uF和10uF的电容进行充分去耦。(**数据手册, 第35页, "POWER SUPPLIES"章节**)。
*   **接地**: 采用**单点接地**或**大面积接地平面**。将`AGND`和`DGND`引脚直接连接到同一个低阻抗的接地平面上。模拟和数字部分的布局应在物理上分开，以防数字噪声耦合到模拟输入端。

---

## **第四章：TMS320F28377D 软件驱动实现**

### **4.1. 驱动开发环境**

*   **IDE**: Code Composer Studio (CCS)
*   **库**: F28x传统库 (F28x_Project.h) - 基于寄存器直接配置
*   **架构**: 三层架构 (Drivers/Framework/Application)

### **4.2. 步骤一：GPIO引脚功能配置**

在驱动层 `Drv_SPI_GPIO_Config()` 和 `Drv_ADS1278_GPIO_Config()` 中实现。

```c
void Drv_SPI_GPIO_Config(void)
{
    EALLOW;
    
    // 配置SPIA引脚 (GPIO54-56)
    // GPIO54: MOSI
    GPIO_SetupPinMux(54, GPIO_MUX_CPU1, 6);  // Mux=6: SPI功能
    GPIO_SetupPinOptions(54, GPIO_OUTPUT, GPIO_PUSHPULL);
    GpioCtrlRegs.GPBPUD.bit.GPIO54 = 0;       // 使能上拉
    GpioCtrlRegs.GPBQSEL2.bit.GPIO54 = 3;     // 异步采样
    
    // GPIO55: MISO (连接ADS1278的DOUT1)
    GPIO_SetupPinMux(55, GPIO_MUX_CPU1, 6);
    GPIO_SetupPinOptions(55, GPIO_INPUT, GPIO_PUSHPULL);
    GpioCtrlRegs.GPBPUD.bit.GPIO55 = 0;       // 使能上拉
    GpioCtrlRegs.GPBQSEL2.bit.GPIO55 = 3;     // 异步采样
    
    // GPIO56: SCLK
    GPIO_SetupPinMux(56, GPIO_MUX_CPU1, 6);
    GPIO_SetupPinOptions(56, GPIO_OUTPUT, GPIO_PUSHPULL);
    
    /* 
     * 注意：GPIO57用于DRDY中断输入，不能作为CS片选。
     * CS片选根据硬件设计：
     * 1. 硬件固定拉低（单片应用，推荐）
     * 2. 使用其他GPIO（如GPIO58、GPIO59等）
     */
    
    EDIS;
}

void Drv_ADS1278_GPIO_Config(void)
{
    EALLOW;
    
    // 配置DRDY输入引脚（GPIO57 - XINT2）
    GPIO_SetupPinMux(57, GPIO_MUX_CPU1, 0);   // GPIO模式
    GPIO_SetupPinOptions(57, GPIO_INPUT, GPIO_PULLUP | GPIO_SYNC);
    GpioCtrlRegs.GPBQSEL2.bit.GPIO57 = 0;     // 同步到SYSCLKOUT（GPIO57在GPBQSEL2中）
    
    // 配置为XINT2外部中断（GPIO57对应XINT2）
    GPIO_SetupXINT2Gpio(57);
    
    EDIS;
    
    /* 
     * 注意：ADS1278的控制引脚（MODE/FORMAT/SYNC/PWDN等）已在硬件上固定连接：
     * - MODE[1:0] = 01 (硬件连接: MODE0接IOVDD, MODE1接GND) → High Resolution模式
     * - FORMAT[2:0] = 001 (硬件连接: FORMAT0接IOVDD, FORMAT1/2接GND) → SPI, TDM, Fixed
     * - SYNC: 硬件上拉或接IOVDD → 采样使能
     * - PWDN: 硬件上拉或接IOVDD → 正常工作
     * - CLKDIV: 根据实际硬件连接
     * - CS: 硬件固定拉低（单片应用）或使用其他GPIO
     * 
     * 因此软件中不需要配置这些GPIO引脚。
     */
}
```

### **4.3. 步骤二：SPI模块参数配置 (权威修正版)**

**关键修正：必须使用SPI Mode 0 (CPOL=0, CPHA=0)，数据在上升沿采样**

```c
void Drv_SPIA_Init(void)
{
    volatile struct SPI_REGS *spi = &SpiaRegs;
    Uint16 brr;
    
    // 使能SPI时钟
    EALLOW;
    CpuSysRegs.PCLKCR8.bit.SPI_A = 1;
    EDIS;
    
    // 复位SPI
    spi->SPICCR.bit.SPISWRESET = 0;  // 进入复位状态
    
    // 计算波特率：SPICLK = LSPCLK / (SPIBRR + 1)
    // 目标10MHz: SPIBRR = (50MHz / 10MHz) - 1 = 4
    brr = (LSPCLK_HZ / 10000000UL) - 1;  // 10MHz SPI时钟
    if(brr < 3) brr = 3;  // 最小值限制
    
    //==========================================================================
    // SPICCR: SPI配置控制寄存器
    //==========================================================================
    spi->SPICCR.all = 0x0000;
    spi->SPICCR.bit.SPICHAR = 15;          // 16位字长 (15表示16位)
    spi->SPICCR.bit.SPILBK = 0;            // 禁用回环模式
    spi->SPICCR.bit.CLKPOLARITY = 0;       // CPOL=0 (时钟空闲低电平)
    
    //==========================================================================
    // SPICTL: SPI操作控制寄存器
    //==========================================================================
    spi->SPICTL.all = 0x0000;
    spi->SPICTL.bit.MASTER_SLAVE = 1;      // 主模式
    spi->SPICTL.bit.CLK_PHASE = 0;         // CPHA=0 (第一个边沿采样) *** 关键 ***
    spi->SPICTL.bit.TALK = 1;              // 使能发送
    spi->SPICTL.bit.SPIINTENA = 0;         // 禁用SPI中断（DMA模式）
    
    //==========================================================================
    // SPIBRR: 波特率寄存器
    //==========================================================================
    spi->SPIBRR.bit.SPI_BIT_RATE = brr;
    
    //==========================================================================
    // SPIFFTX: FIFO发送控制寄存器
    //==========================================================================
    spi->SPIFFTX.all = 0xC000;             // 复位FIFO，增强模式
    spi->SPIFFTX.bit.SPIFFENA = 1;         // 使能FIFO
    spi->SPIFFTX.bit.TXFIFO = 1;           // 释放TX FIFO
    spi->SPIFFTX.bit.TXFFIENA = 0;         // 禁用TX FIFO中断
    spi->SPIFFTX.bit.TXFFINTCLR = 1;       // 清中断标志
    spi->SPIFFTX.bit.TXFFIL = 0;           // TX FIFO触发电平：0=FIFO空时触发
    
    //==========================================================================
    // SPIFFRX: FIFO接收控制寄存器
    //==========================================================================
    spi->SPIFFRX.all = 0x0000;
    spi->SPIFFRX.bit.RXFIFORESET = 1;      // 释放RX FIFO
    spi->SPIFFRX.bit.RXFFIENA = 0;         // 禁用RX FIFO中断
    spi->SPIFFRX.bit.RXFFINTCLR = 1;       // 清中断标志
    spi->SPIFFRX.bit.RXFFIL = 12;          // RX FIFO触发电平：12字触发DMA
    spi->SPIFFRX.bit.RXFFOVFCLR = 1;       // 清溢出标志
    
    //==========================================================================
    // SPIFFCT: FIFO控制寄存器
    //==========================================================================
    spi->SPIFFCT.all = 0x0000;             // FIFO传输延迟=0
    
    //==========================================================================
    // SPIPRI: 优先级控制寄存器
    //==========================================================================
    spi->SPIPRI.all = 0x0000;
    spi->SPIPRI.bit.FREE = 1;              // 调试模式下继续运行
    
    // 释放SPI复位
    spi->SPICCR.bit.SPISWRESET = 1;
    
    DELAY_US(10);  // 稳定延迟
}
```

**SPI Mode 0配置说明：**
- `CLKPOLARITY = 0` (CPOL=0): SCLK空闲时为低电平
- `CLK_PHASE = 0` (CPHA=0): 在第一个时钟边沿（上升沿）采样数据
- 这与ADS1278数据手册第697、703行的描述完全一致：
  - ADS1278在SCLK下降沿输出数据
  - 主机应在SCLK上升沿采样数据

### **4.4. 步骤三：`DRDY`外部中断(XINT)配置**

```c
// 在interrupt.c中声明
__interrupt void ADS1278_DRDY_ISR(void);

void Drv_ADS1278_InitInterrupt(void)
{
    EALLOW;
    
    // 配置XINT2为下降沿触发（GPIO57对应XINT2）
    XintRegs.XINT2CR.bit.POLARITY = 0;  // 0=下降沿触发
    XintRegs.XINT2CR.bit.ENABLE = 1;    // 使能XINT2
    
    // 注册中断向量
    PieVectTable.XINT2_INT = &ADS1278_DRDY_ISR;
    
    // 使能PIE中断（PIE1.5 - XINT2）
    PieCtrlRegs.PIEIER1.bit.INTx5 = 1;  // 使能PIE组1的INT5
    IER |= M_INT1;                       // 使能CPU INT1组
    
    EDIS;
}
```

### **4.5. 步骤四：双通道DMA控制器配置 (核心)**

使用DMA通道1进行接收（SPIA RX），通道2进行发送（SPIA TX）。

```c
#define DMA_ADC_BUFFER_SIZE 12  // 12个16位字 = 24字节 (8通道×3字节)
#define DMA_BURST_SPIA_RX   11  // BURST_SIZE = 传输字数-1 = 11
#define DMA_BURST_SPIA_TX   11

// Ping-Pong双缓冲区（在drv_dma_buffers.c中定义）
Uint16 g_adc_rx_ping[DMA_ADC_BUFFER_SIZE];
Uint16 g_adc_rx_pong[DMA_ADC_BUFFER_SIZE];
Uint16 g_adc_tx_dummy[DMA_ADC_BUFFER_SIZE];  // 虚拟数据

void Drv_DMA_Init(void)
{
    EALLOW;
    
    // 调用TI官方库初始化DMA
    DMAInitialize();
    
    // 调试模式下DMA继续运行
    DmaRegs.DEBUGCTRL.bit.FREE = 1;
    
    // 配置CH1高优先级模式
    DmaRegs.PRIORITYCTRL1.bit.CH1PRIORITY = 1;
    DmaRegs.DMACTRL.bit.PRIORITYRESET = 1;
    
    EDIS;
}

void Drv_DMA_ConfigChannel_SPIA_RX(void)
{
    EALLOW;
    
    // 配置地址：源=SPIRXBUF，目标=adc_rx_ping
    DMACH1AddrConfig(&g_adc_rx_ping[0], (volatile Uint16 *)&SpiaRegs.SPIRXBUF);
    
    // 配置BURST：12字传输（BURST_SIZE=11）
    // SRCBURST=0（源地址不变，FIFO固定地址）
    // DSTBURST=1（目标地址递增1字）
    DMACH1BurstConfig(DMA_BURST_SPIA_RX, 0, 1);
    
    // 配置TRANSFER：1次BURST后完成（ONESHOT模式）
    // TRANSFER_SIZE=0表示1次BURST
    DMACH1TransferConfig(0, 0, 1);
    
    // 配置WRAP：不使用
    DMACH1WrapConfig(0, 0, 0, 0);
    
    // 配置MODE
    DMACH1ModeConfig(
        DMA_SPIARX,         // 触发源：SPIA RX FIFO (110)
        PERINT_ENABLE,      // 使能外设中断触发
        ONESHOT_ENABLE,     // ONESHOT模式（传输完成后自动停止）
        CONT_DISABLE,       // 禁用连续模式
        SYNC_DISABLE,       // 禁用同步
        SYNC_SRC,           // 同步源（SYNC_DISABLE时忽略）
        OVRFLOW_DISABLE,    // 禁用溢出中断
        SIXTEEN_BIT,        // 16位数据宽度
        CHINT_END,          // 传输结束时产生中断
        CHINT_ENABLE        // 使能DMA通道中断
    );
    
    EDIS;
}

void Drv_DMA_ConfigChannel_SPIA_TX(void)
{
    Uint16 i;
    
    // 填充虚拟数据（用于产生SCLK）
    for(i = 0; i < DMA_ADC_BUFFER_SIZE; i++) {
        g_adc_tx_dummy[i] = 0x0000;
    }
    
    EALLOW;
    
    // 配置地址：源=dummy_tx，目标=SPITXBUF
    DMACH2AddrConfig((volatile Uint16 *)&SpiaRegs.SPITXBUF, &g_adc_tx_dummy[0]);
    
    // 配置BURST：12字传输（BURST_SIZE=11）
    // SRCBURST=1（源地址递增1字）
    // DSTBURST=0（目标地址不变，FIFO固定地址）
    DMACH2BurstConfig(DMA_BURST_SPIA_TX, 1, 0);
    
    // 配置TRANSFER：1次BURST后完成
    DMACH2TransferConfig(0, 1, 0);
    
    // 配置WRAP：不使用
    DMACH2WrapConfig(0, 0, 0, 0);
    
    // 配置MODE
    DMACH2ModeConfig(
        DMA_SPIATX,         // 触发源：SPIA TX FIFO (109)
        PERINT_ENABLE,
        ONESHOT_ENABLE,
        CONT_DISABLE,
        SYNC_DISABLE,
        SYNC_SRC,
        OVRFLOW_DISABLE,
        SIXTEEN_BIT,
        CHINT_END,
        CHINT_ENABLE
    );
    
    EDIS;
}

void Drv_DMA_RegisterInterrupt(void)
{
    EALLOW;
    
    // 注册DMA中断向量
    PieVectTable.DMA_CH1_INT = &DMA_CH1_ISR;  // PIE7.1
    PieVectTable.DMA_CH2_INT = &DMA_CH2_ISR;  // PIE7.2
    
    // 使能PIE中断
    PieCtrlRegs.PIEIER7.bit.INTx1 = 1;  // DMA CH1
    PieCtrlRegs.PIEIER7.bit.INTx2 = 1;  // DMA CH2
    IER |= M_INT7;                       // 使能CPU INT7组
    
    EDIS;
}
```

---

## **第五章：完整软件工作流程与代码实现**

### **5.1. 初始化流程**

基于三层架构的初始化流程（Application层调用）。

```c
// 在Application/app_init.c中实现
void App_Init(void)
{
    //========================================================================
    // 1. Drivers层初始化
    //========================================================================
    
    // 系统时钟和核心初始化
    InitSysCtrl();          // 配置200MHz系统时钟
    InitGpio();             // GPIO初始化
    
    // 中断系统初始化
    DINT;                   // 禁用全局中断
    InitPieCtrl();          // PIE控制器初始化
    IER = 0x0000;           // 禁用所有CPU中断
    IFR = 0x0000;           // 清除所有中断标志
    InitPieVectTable();     // 初始化PIE中断向量表
    
    // SPI GPIO配置
    Drv_SPI_GPIO_Config();
    
    // ADS1278 GPIO配置
    Drv_ADS1278_GPIO_Config();
    
    // SPI模块初始化
    Drv_SPIA_Init();
    
    // DMA初始化
    Drv_DMA_Init();
    Drv_DMA_ConfigChannel_SPIA_RX();
    Drv_DMA_ConfigChannel_SPIA_TX();
    Drv_DMA_RegisterInterrupt();
    
    // ADS1278驱动初始化
    Drv_ADS1278_InitDefault();
    Drv_ADS1278_InitInterrupt();
    
    //========================================================================
    // 2. Framework层初始化
    //========================================================================
    
    // 任务调度器初始化
    Scheduler_Init();
    
    //========================================================================
    // 3. 使能全局中断
    //========================================================================
    
    EINT;   // 使能全局中断
    ERTM;   // 使能实时调试
}

// 在Application/app_main.c中
void main(void)
{
    // 应用初始化
    App_Init();
    
    /* 
     * 注意：由于ADS1278的SYNC引脚已在硬件上固定连接（上拉或接IOVDD），
     * 芯片在上电后自动进入连续采样模式，无需软件调用启动函数。
     * 因此不需要 Drv_ADS1278_Start() 函数。
     */
    
    // 主循环
    while(1)
    {
        // 应用任务
        App_Task_UserMainLoop();
        
        // 任务调度器运行
        Scheduler_Run();
    }
}
```

### **5.2. `DRDY`中断服务程序 (XINT ISR)**

此ISR必须极度精简，只做一件事：触发ADC读取。任何多余的操作都会增加延迟。

```c
// 在Drivers/drv_ads1278.c中实现
__interrupt void ADS1278_DRDY_ISR(void)
{
    // 触发ADC读取（内部会启动DMA传输）
    Drv_ADS1278_TriggerRead();
    
    // 调用用户回调（如果已注册）
    if(g_ads1278_callback != NULL) {
        g_ads1278_callback();
    }
    
    // 清除中断标志
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

// Drv_ADS1278_TriggerRead()内部实现
bool Drv_ADS1278_TriggerRead(void)
{
    Uint16 *target_buffer;
    
    // 检查DMA是否忙碌
    if(!g_dma_ch1_done || !g_dma_ch2_done) {
        return false;  // 上一次传输还未完成
    }
    
    // 选择Ping或Pong缓冲区
    target_buffer = g_ads1278_ping_active ? 
                    &g_adc_rx_ping[0] : 
                    &g_adc_rx_pong[0];
    
    // 清空SPI FIFO
    Drv_SPI_ClearFIFO(SPI_MODULE_A);
    
    // 重新配置DMA地址
    Drv_DMA_ReConfigAddr(DMA_CH1, &SpiaRegs.SPIRXBUF, target_buffer, DMA_BURST_SPIA_RX);
    Drv_DMA_ReConfigAddr(DMA_CH2, &g_adc_tx_dummy[0], &SpiaRegs.SPITXBUF, DMA_BURST_SPIA_TX);
    
    // 清除DMA完成标志
    g_dma_ch1_done = false;
    g_dma_ch2_done = false;
    
    /* 
     * 注意：如果CS片选硬件固定拉低，则不需要软件控制CS。
     * 如果CS使用其他GPIO控制，则在此处拉低CS。
     */
    // Drv_SPI_SetCS(SPI_MODULE_A, true);  // 如果需要软件控制CS
    
    // 启动DMA传输（RX先启动，TX后启动）
    Drv_DMA_StartPair(DMA_CH1, DMA_CH2);
    
    return true;
}
```

### **5.3. DMA中断服务程序 (DMA ISR)**

当DMA搬运完所有数据后，此ISR被触发，执行数据转换和标志设置。

```c
// 在Drivers/drv_dma.c中实现
__interrupt void DMA_CH1_ISR(void)
{
    volatile struct CH_REGS* ch1 = &DmaRegs.CH1;
    
    EALLOW;
    
    // 停止DMA通道
    ch1->CONTROL.bit.HALT = 1;
    
    // 清除溢出标志（如果有）
    if(ch1->CONTROL.bit.OVRFLG) {
        ch1->CONTROL.bit.OVRFLG = 1;  // 写1清除
        g_dma_stats[DMA_CH1].overflow_count++;
    }
    
    // 清除同步标志（如果有）
    if(ch1->CONTROL.bit.SYNCFLG) {
        ch1->CONTROL.bit.SYNCFLG = 1;
    }
    
    EDIS;
    
    // 清除PIE中断标志
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;
    
    // 设置完成标志
    g_dma_ch1_done = true;
    
    // 更新统计计数
    g_dma_stats[DMA_CH1].complete_count++;
    
    // 调用回调函数（在这里执行数据转换）
    if(g_dma_callbacks[DMA_CH1] != NULL) {
        g_dma_callbacks[DMA_CH1]();
    }
}

__interrupt void DMA_CH2_ISR(void)
{
    volatile struct CH_REGS* ch2 = &DmaRegs.CH2;
    
    EALLOW;
    ch2->CONTROL.bit.HALT = 1;
    if(ch2->CONTROL.bit.OVRFLG) {
        ch2->CONTROL.bit.OVRFLG = 1;
        g_dma_stats[DMA_CH2].overflow_count++;
    }
    if(ch2->CONTROL.bit.SYNCFLG) {
        ch2->CONTROL.bit.SYNCFLG = 1;
    }
    EDIS;
    
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;
    g_dma_ch2_done = true;
    g_dma_stats[DMA_CH2].complete_count++;
    
    if(g_dma_callbacks[DMA_CH2] != NULL) {
        g_dma_callbacks[DMA_CH2]();
    }
}

// DMA完成回调（在drv_ads1278.c中实现并注册）
void Drv_ADS1278_DMA_RxCallback(void)
{
    Uint16 *src_buffer;
    
    /* 如果CS使用其他GPIO控制，则在此处拉高CS */
    // Drv_SPI_SetCS(SPI_MODULE_A, false);  // 如果需要软件控制CS
    
    // 选择刚刚接收数据的缓冲区
    src_buffer = g_ads1278_ping_active ? 
                 &g_adc_rx_ping[0] : 
                 &g_adc_rx_pong[0];
    
    // 转换数据到最新数据缓存
    Drv_ADS1278_ConvertData(src_buffer, &g_ads1278_latest_data);
    
    // 切换Ping-Pong缓冲区
    g_ads1278_ping_active = !g_ads1278_ping_active;
}
```

### **5.4. 主循环 (`main loop`) 数据处理**

主循环通过检查数据标志位来处理ADC数据。数据处理与数据采集完全解耦。

```c
// 在Application/app_task.c中实现
void App_Task_UserMainLoop(void)
{
    ADS1278_Data_t adc_data;
    
    // 检查是否有新数据
    if(Drv_ADS1278_IsDataReady())
    {
        // 获取最新ADC数据
        if(Drv_ADS1278_GetData(&adc_data))
        {
            // 数据处理逻辑
            App_ProcessAdcData(&adc_data);
        }
    }
}

void App_ProcessAdcData(ADS1278_Data_t *data)
{
    Uint16 i;
    float voltage;
    
    // 遍历所有通道
    for(i = 0; i < ADS1278_CHANNELS; i++)
    {
        // 将24位补码转换为电压值
        // V = (ADC_Code / 2^23) * VREF
        voltage = (float)data->ch[i] * (2.5f / 8388608.0f);
        
        // 您的核心算法处理
        // 例如：滤波、FFT、振动分析等
        
        // 示例：简单的阈值检测
        if(voltage > 2.0f || voltage < -2.0f) {
            // 电压超出范围
        }
    }
}
```

### **5.5. 完整的代码框架示例**

基于三层架构的完整实现。代码分布在多个模块中。

```
项目结构：
Prj03/
├── Drivers/               (硬件抽象层)
│   ├── drv_ads1278.c/h   (ADS1278专用驱动)
│   ├── drv_spi.c/h       (SPI通用驱动)
│   ├── drv_dma.c/h       (DMA通用驱动)
│   ├── drv_dma_buffers.c/h (Ping-Pong缓冲)
│   └── drv_system.c/h    (系统初始化)
├── Framework/            (调度框架)
│   ├── task_scheduler.c/h (任务调度器)
│   └── system_config.h   (系统配置)
└── Application/          (应用层)
    ├── app_init.c/h      (应用初始化)
    ├── app_task.c/h      (应用任务)
    └── app_main.c        (主程序入口)
```

**核心文件示例：**

**Application/app_main.c (主程序)**
```c
#include "app_init.h"
#include "app_task.h"
#include "../Framework/task_scheduler.h"

void main(void)
{
    // 应用初始化
    App_Init();
    
    /* ADS1278的SYNC引脚硬件上拉，上电后自动进入连续采样模式 */
    
    // 主循环
    while(1)
    {
        // 用户主循环任务
        App_Task_UserMainLoop();
        
        // 任务调度器运行
        Scheduler_Run();
    }
}
```

**Application/app_task.c (应用任务)**
```c
#include "app_task.h"
#include "../Drivers/drv_ads1278.h"

void App_Task_UserMainLoop(void)
{
    ADS1278_Data_t adc_data;
    
    // 检查并获取新数据
    if(Drv_ADS1278_GetData(&adc_data))
    {
        App_ProcessAdcData(&adc_data);
    }
}

void App_ProcessAdcData(ADS1278_Data_t *data)
{
    Uint16 i;
    float voltage;
    
    for(i = 0; i < ADS1278_CHANNELS; i++)
    {
        // 转换为电压值
        voltage = (float)data->ch[i] * (2.5f / 8388608.0f);
        
        // 您的核心算法处理
        // ...
    }
}
```

**Drivers/drv_ads1278.h (关键数据结构)**
```c
// ADS1278采样数据结构
typedef struct {
    int32  ch[8];         // 8通道24位数据（符号扩展到32位）
    Uint32 timestamp;     // 时间戳
    Uint16 sample_id;     // 样本序号
    bool   valid;         // 数据有效标志
    bool   overflow;      // 溢出标志
} ADS1278_Data_t;

// 主要API
bool Drv_ADS1278_InitDefault(void);      // 初始化驱动
bool Drv_ADS1278_GetData(ADS1278_Data_t *data);  // 获取最新数据
bool Drv_ADS1278_IsDataReady(void);      // 检查数据是否就绪

/* 
 * 注意：由于硬件固定连接，以下函数不需要：
 * - Drv_ADS1278_Start()/Stop()    (SYNC硬件固定)
 * - Drv_ADS1278_SetMode()         (MODE硬件固定)
 * - Drv_ADS1278_SetFormat()       (FORMAT硬件固定)
 * - Drv_ADS1278_SetClkDiv()       (CLKDIV硬件固定)
 */
```

**完整代码请参考工作空间中的实际实现。**

---

## **第六章：24位ADC数据解析与电压转换**

### **6.1. 数据在内存中的布局**

`spiRxBuffer` (长度24) 中存储的是原始的ADC读数。由于我们配置SPI为8位模式，F28377D的16位`SPIRXBUF`高8位为0，所以`spiRxBuffer`每个`uint16_t`元素实际只包含8位有效数据。

```
spiRxBuffer[0]  -> Channel 1, MSB
spiRxBuffer[1]  -> Channel 1, Mid-Byte
spiRxBuffer[2]  -> Channel 1, LSB
...
spiRxBuffer[21] -> Channel 8, MSB
spiRxBuffer[22] -> Channel 8, Mid-Byte
spiRxBuffer[23] -> Channel 8, LSB
```

### **6.2. 解析步骤详解**

#### **6.2.1. 字节组合**
将每个通道的3个8位数据（存储在3个`uint16_t`中）组合成一个32位整数。

#### **6.2.2. 符号位扩展 (关键步骤)**
原始数据是24位的补码。如果其最高位（第24位，即MSB的bit7）是1，表示这是一个负数。当把它存入一个32位的`int32_t`变量时，必须将高8位（第25到32位）全部置为1，以保持其负值不变。这称为符号位扩展。

#### **6.2.3. 标度变换与电压计算**
*   **公式**: `Voltage = (ADC_Code / 2^23) * V_REF`
*   `ADC_Code`: 经过符号位扩展后的32位有符号整数值。
*   `2^23`: `8,388,608`。这是24位ADC的正数范围。
*   `V_REF`: ADS1278的参考电压，例如2.5V。

### **6.3. 数据解析函数示例**

在 `Drivers/drv_ads1278.c` 中实现。

```c
// 从16位缓冲区转换24位ADC数据
void Drv_ADS1278_ConvertData(Uint16 *src_buffer, ADS1278_Data_t *dest_data)
{
    Uint16 i, word_idx;
    Uint32 raw_data;
    
    if(src_buffer == NULL || dest_data == NULL) {
        return;
    }
    
    // ADS1278每通道24位，分为3个8位字节传输
    // 使用16位SPI字长时，每通道占用1.5个16位字
    // 实际上，24字节÷2 = 12个16位字
    
    // 重组数据：每个通道由连续的3个字节组成
    for(i = 0; i < ADS1278_CHANNELS; i++) {
        word_idx = (i * 3) / 2;  // 计算起始字索引
        
        if((i * 3) % 2 == 0) {
            // 偶数通道：从偶数字节开始
            // [Word0_H8 Word0_L8] [Word1_H8 Word1_L8]
            // CH0: Word0_H8, Word0_L8, Word1_H8
            raw_data = ((Uint32)src_buffer[word_idx] << 8) | 
                       ((Uint32)(src_buffer[word_idx + 1] >> 8) & 0xFF);
        } else {
            // 奇数通道：从奇数字节开始
            // CH1: Word1_L8, Word2_H8, Word2_L8
            raw_data = ((Uint32)(src_buffer[word_idx] & 0xFF) << 16) | 
                       ((Uint32)src_buffer[word_idx + 1]);
        }
        
        // 符号扩展24位到32位
        dest_data->ch[i] = ADS1278_SIGN_EXTEND_24_TO_32(raw_data);
    }
    
    // 更新元数据
    dest_data->timestamp = g_ads1278_sample_count;
    dest_data->sample_id = g_ads1278_sample_count;
    dest_data->valid = true;
    dest_data->overflow = false;
    
    g_ads1278_sample_count++;
}

// 符号扩展宏（在drv_ads1278.h中定义）
#define ADS1278_SIGN_EXTEND_24_TO_32(x)  \
    (((x) & 0x800000) ? ((x) | 0xFF000000) : (x))
```

**数据转换说明：**
1. **16位字长传输**：SPI配置为16位，但ADS1278每通道输出24位（3字节）
2. **字节对齐处理**：偶数通道和奇数通道的字节边界不同，需分别处理
3. **符号扩展**：24位补码的最高位（第23位）是符号位，需扩展到32位的高8位
4. **电压转换**：在应用层进行，公式为 `V = (ADC_Code / 2^23) * VREF`

---

## **第七章：调试、验证与常见问题(FAQ)**

### **7.1. 常用调试工具**
*   **逻辑分析仪**: 调试SPI通信的**神器**。必须连接到`SCLK`, `MISO`, `DRDY`线上，直观地检查时序是否正确，数据是否有效。
*   **CCS调试器**: 使用断点和表达式观察窗口，在`parseAdcData()`执行后，实时查看`spiRxBuffer`的原始数据和`channel_voltages`的最终计算结果。

### **7.2. 常见问题与解决方案**

1.  **问：`DRDY`中断从未触发？**
    *   **答：** 检查ADS1278的`CLK`引脚是否有稳定的27MHz时钟。这是ADC工作的先决条件。同时用示波器确认`DRDY`引脚是否有脉冲输出。

2.  **问：收到的数据全是0或全是0xFF？**
    *   **答：** 99%的可能性是**SPI模式配置错误**。请严格按照本指南，配置为**SPI Mode 0**。其次，检查硬件连接是否牢固。

3.  **问：DMA中断从未触发？**
    *   **答：** 检查`initSpia()`函数中，`SPI_enableDMATx()`和`SPI_enableDMARx()`是否被调用。这是SPI向DMA发出请求的“开关”。

4.  **问：解析出的电压值只有正数，或数值不正确？**
    *   **答：** **符号位扩展**步骤被遗漏或实现错误。请仔细核对`parseAdcData()`函数中的`if(raw_val & 0x00800000)`逻辑。

5.  **问：系统偶尔会丢失数据？**
    *   **答：** 检查`SCLK`频率是否足够快，确保在下一次`DRDY`到来之前能读完24字节。计算公式：`Time_to_read = (8 bits * 24) / SCLK_Freq`。这个时间必须小于 `1 / f_DATA`。在本方案中 `192 / 10MHz = 19.2μs << 1 / 52.7kHz = 19μs`，时间裕量充足。如果仍然丢数，请检查主循环中是否有长时间关中断或高优先级的任务抢占。

---

## **附录**

### **A. 关键参数的数据手册来源索引**

*   **工作模式 (`MODE`)**: 第26页, 表9
*   **接口格式 (`FORMAT`)**: 第30页, 表14
*   **SPI时序图**: 第8页, "SPI FORMAT TIMING"
*   **数据输出速率与`CLK`关系**: 第26页, 表8
*   **24位补码数据格式**: 第24页, 表5
*   **电源要求**: 第35页, "POWER SUPPLIES"

---

### **B. 当前工作空间代码修正指南**

**重要提示：** 本文档V3.0已根据工作空间实际代码架构进行了修正，采用F28x传统库API。

#### **硬件连接说明**

ADS1278的控制引脚已在PCB硬件上固定连接，无需软件配置：

**硬件固定连接（参考第2章配置要求）：**
- **MODE[1:0] = 01**：MODE0接IOVDD(3.3V)，MODE1接GND → High Resolution模式，52.7kSPS
- **FORMAT[2:0] = 001**：FORMAT0接IOVDD，FORMAT1和FORMAT2接GND → SPI协议，TDM模式，固定位置
- **SYNC**：上拉至IOVDD或直接接IOVDD → 连续采样模式
- **PWDN**：上拉至IOVDD或直接接IOVDD → 正常工作（非掉电）
- **CLKDIV**：根据实际CLK频率连接（27MHz时接IOVDD，不分频）
- **DIN**：接GND（单片应用，不使用菊花链）

**软件只需配置：**
- ✅ DRDY中断引脚（GPIO57 → XINT2）
- ✅ SPI引脚（GPIO54-56：MOSI/MISO/SCLK）
- ℹ️ CS片选：硬件固定拉低（单片应用）或使用其他GPIO

**软件中移除的函数（硬件已固定）：**
- ❌ `Drv_ADS1278_Start()/Stop()` - SYNC引脚硬件固定，始终采样
- ❌ `Drv_ADS1278_SetMode()` - MODE引脚硬件固定为High Resolution
- ❌ `Drv_ADS1278_SetFormat()` - FORMAT引脚硬件固定为SPI TDM模式
- ❌ `Drv_ADS1278_SetClkDiv()` - CLKDIV引脚硬件固定
- ❌ `Drv_ADS1278_SoftReset()` - PWDN引脚硬件固定，无需软件复位

**优势：**
- 极大简化软件复杂度
- 避免GPIO资源占用（节省5个GPIO）
- 配置更可靠（不受软件bug影响）
- 驱动代码更精简

---

#### **必须修正的问题：SPI Mode配置错误**

**问题位置：** `Drivers/drv_spi.c` 第201行和第138行

**当前错误配置：**
```c
// drv_spi.c 第201行
config.mode = SPI_MODE_1;  // ❌ 错误：CPOL=0, CPHA=1

// drv_spi.c 第138行
spi->SPICTL.bit.CLK_PHASE = (config->mode & 0x01);  // CPHA=1
```

**正确配置应为：**
```c
// drv_spi.c 第201行
config.mode = SPI_MODE_0;  // ✅ 正确：CPOL=0, CPHA=0

// drv_spi.c 第138行
// 当mode=0时，CLK_PHASE = 0
```

**修正原理：**

根据ADS1278数据手册第697行和703行：
- ADS1278在SCLK**下降沿**输出数据
- 主机应在SCLK**上升沿**采样数据

SPI Mode 0 (CPOL=0, CPHA=0) 配置：
- CPOL=0：SCLK空闲时为**低电平**
- CPHA=0：在**第一个时钟边沿（上升沿）采样数据** ✅ 正确

SPI Mode 1 (CPOL=0, CPHA=1) 配置：
- CPOL=0：SCLK空闲时为**低电平**
- CPHA=1：在**第二个时钟边沿（下降沿）采样数据** ❌ 错误（时序错位）

**具体修改步骤：**

1. 打开 `Drivers/drv_spi.c`
2. 找到第201行，将 `SPI_MODE_1` 改为 `SPI_MODE_0`：
   ```c
   void Drv_SPIA_Init(void)
   {
       SPI_Config_t config;
       
       config.module = SPI_MODULE_A;
       config.clock_hz = SPIA_CLOCK_HZ;
       config.mode = SPI_MODE_0;  // ← 修改这里
       config.data_width = 16;
       // ...
   }
   ```

3. 同样地，如果 `Drivers/drv_spi.h` 中有注释说明Mode 1是推荐模式，也需要更新：
   ```c
   // 修改前：
   SPI_MODE_1 = 1,  // CPOL=0, CPHA=1 (ADS1278/AD5754推荐)
   
   // 修改后：
   SPI_MODE_0 = 0,  // CPOL=0, CPHA=0 (ADS1278要求)
   SPI_MODE_1 = 1,  // CPOL=0, CPHA=1 (AD5754可用)
   ```

**验证方法：**

修改后，可通过以下方式验证：
1. 使用逻辑分析仪观察SCLK和MISO信号
2. 检查读取的ADC数据是否合理（不应全为0或0xFFFFFF）
3. 验证数据是否在SCLK上升沿稳定

---

### **C. 代码架构说明**

本文档第四章和第五章的代码示例已完全基于工作空间的三层架构：

**Drivers层（硬件抽象层）：**
- `drv_ads1278.c/h` - ADS1278专用驱动（精简版，仅数据采集和转换）
- `drv_spi.c/h` - SPI通用驱动，支持多个SPI设备
- `drv_dma.c/h` - DMA通用驱动，支持多通道配置
- `drv_dma_buffers.c/h` - Ping-Pong双缓冲实现

**Framework层（调度框架）：**
- `task_scheduler.c/h` - 任务调度器
- `system_config.h` - 系统参数配置

**Application层（应用逻辑）：**
- `app_init.c/h` - 应用初始化
- `app_task.c/h` - 应用任务（数据处理）
- `app_main.c` - 主程序入口

**优势：**
- 模块化设计，易于维护和扩展
- 硬件抽象，应用层无需关心寄存器细节
- 支持多设备（ADS1278 + AD5754）
- Ping-Pong缓冲机制，避免数据覆盖
- 完善的错误处理和统计功能

---

### **D. 版本历史**

**V3.0 - 2025-10-21 (当前版本)**
- ✅ 修正为基于F28x传统库的实现
- ✅ 采用工作空间实际三层架构
- ✅ 修正所有API调用为寄存器直接配置
- ✅ 明确标注SPI Mode 0配置的正确性
- ✅ 添加Ping-Pong缓冲和DMA回调机制
- ✅ 适配硬件固定连接设计（移除软件控制函数）
- ⚠️ 指出当前项目SPI Mode 1的配置错误

**V2.0（废弃）**
- 基于DriverLib库的示例（与工作空间不兼容）

**V1.0（废弃）**
- 初始版本

---

### **E. 参考文档**

1. **ADS1278数据手册** - SBAS417C (Texas Instruments)
   - 关键章节：SPI时序图（第8页）、数据格式（第24-30页）
2. **TMS320F28377D技术参考手册** - SPRUHI8B (Texas Instruments)
   - 关键章节：SPI模块、DMA模块、PIE中断系统
3. **F28x外设驱动库用户指南** - SPRU566 (Texas Instruments)

---
**文档结束 - V3.0 权威修正版**
