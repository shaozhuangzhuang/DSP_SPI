# 看门狗使用说明

**模块名称**: TMS320F28377D 内部看门狗驱动  
**文件位置**: `Drivers/drv_watchdog.c` 和 `Drivers/drv_watchdog.h`  
**创建日期**: 2025-10-21  
**版本**: v1.1  
**参考**: TI官方示例 `C:\ti\c2000\C2000Ware_5_04_00_00\device_support\f2837xd\examples\cpu1\watchdog`

---

## 📋 功能概述

看门狗模块为系统提供硬件级的安全保护机制，当程序陷入死循环或卡死时，自动触发系统复位，恢复正常运行。

### 核心特性
- ✅ 自动检测并记录看门狗复位事件
- ✅ 可配置的超时窗口时间
- ✅ 集成到任务调度器，自动喂狗
- ✅ 零警告、零错误编译

---

## ⚙️ 配置参数

### 当前配置（已优化）

```c
// drv_watchdog.h
#define WATCHDOG_PRESCALER      SYSCTL_WD_PRESCALE_64   // 预分频：64
#define WATCHDOG_WINDOW_VALUE   0xFF                     // 窗口值：255
```

### 时序参数计算

```
看门狗时钟频率 (WDCLK):
  WDCLK = INTOSC1 / 512 / WDPS
        = 10MHz / 512 / 64
        ≈ 305 Hz

看门狗超时时间:
  Timeout = (WDCNTR + 1) / WDCLK
          = (255 + 1) / 305Hz
          ≈ 839 ms

实际喂狗频率:
  Feed Rate = 50 Hz (每20ms喂一次)
  
安全裕量:
  Margin = 839ms / 20ms ≈ 42倍 ✅ 非常安全
```

---

## 🔌 系统集成

### 初始化流程

看门狗在系统启动时自动初始化（位置：`Application/app_init.c`）：

```c
void App_Init(void)
{
    Drv_System_Init();      // 1. 系统时钟、GPIO初始化
    Drv_Watchdog_Init();    // 2. 看门狗初始化 ← 这里
    Drv_Timer_Init();       // 3. 定时器初始化
    // ... 其他初始化
}
```

### 喂狗机制

喂狗操作集成在任务调度器中（位置：`Framework/task_scheduler.c`）：

```c
void Scheduler_Run(void)
{
    // 执行各种任务...
    
    // 每20ms喂一次狗（与数据任务同步）
    if(data_task_counter == 0)
    {
        Drv_Watchdog_Service();
    }
}
```

**工作原理：**
- 主循环持续调用 `Scheduler_Run()`
- 每20ms执行一次数据处理任务
- 任务执行完成后立即喂狗
- 如果任何任务卡死，`Scheduler_Run()` 无法返回，喂狗停止
- 看门狗超时（~839ms），系统自动复位

---

## 📚 API 参考

### Drv_Watchdog_Init()

**功能**: 看门狗初始化  
**原型**: `void Drv_Watchdog_Init(void)`  
**调用时机**: 系统启动时，在 `App_Init()` 中调用一次  
**执行步骤**:
1. 检测是否为看门狗复位（读取复位状态寄存器）
2. 如果是看门狗复位，递增复位计数器
3. 配置预分频器和窗口值
4. 使能看门狗
5. 立即喂一次狗

**示例**:
```c
// 在 App_Init() 中调用
Drv_Watchdog_Init();
```

---

### Drv_Watchdog_Service()

**功能**: 看门狗喂狗服务（清除看门狗计数器）  
**原型**: `void Drv_Watchdog_Service(void)`  
**调用时机**: 在任务调度器中自动调用，每20ms一次  
**⚠️ 重要**: **禁止在中断服务程序（ISR）中调用！**

**原理**:
- 递增喂狗计数器（用于调试统计）
- 调用 `SysCtl_serviceWatchdog()` 清除看门狗计数器

**示例**:
```c
// 在 Scheduler_Run() 中自动调用
Drv_Watchdog_Service();
```

---

## ⚠️ 重要注意事项

### 1. 禁止在中断中喂狗

```c
// ❌ 错误示例
interrupt void timer_isr(void)
{
    Drv_Watchdog_Service();  // 千万不要这样做！
    // ...
}
```

**原因**: 如果在中断中喂狗，即使主循环卡死，中断仍可能正常执行，导致看门狗失效。

---

### 2. 调试时临时禁用看门狗

如果需要单步调试或暂停程序，可以临时禁用看门狗：

```c
// 在 Drv_Watchdog_Init() 中注释掉使能语句
void Drv_Watchdog_Init(void)
{
    // ... 其他代码 ...
    
    // SysCtl_enableWatchdog();  // ← 注释掉这行
}
```

**调试完成后，务必恢复！**

---

### 3. 窗口时间调整

如果需要修改超时时间，调整 `WATCHDOG_WINDOW_VALUE`：

```c
// drv_watchdog.h
#define WATCHDOG_WINDOW_VALUE   0x80   // 缩短超时：约419ms
#define WATCHDOG_WINDOW_VALUE   0xFF   // 默认：约839ms（推荐）
```

**公式**:
```
Timeout (ms) = (WATCHDOG_WINDOW_VALUE + 1) / 305 * 1000
```

---

## 🧪 功能测试

### 测试1：正常运行测试

**目的**: 验证看门狗不会误触发复位

**步骤**:
1. 编译并烧录程序
2. 观察LED正常闪烁（LED0: 1秒，LED1: 3秒）
3. 运行至少5分钟

**预期结果**: ✅ 系统稳定运行，无意外复位

---

### 测试2：看门狗触发测试

**目的**: 验证看门狗能检测到程序卡死

**步骤**:
1. 在 `Application/app_task.c` 的 `App_Task_DataProcess()` 中添加测试代码：

```c
void App_Task_DataProcess(void)
{
    static Uint16 test_counter = 0;
    test_counter++;
    
    // 测试：10秒后停止喂狗
    if(test_counter > 500)  // 500 × 20ms = 10秒
    {
        while(1)  // 死循环模拟程序卡死
        {
            asm(" NOP");
        }
    }
    
    // 正常任务逻辑...
    App_Task_ADC_Sample();
    App_Task_DAC_Output();
}
```

2. 编译并烧录
3. 观察LED闪烁
4. 等待10秒后，LED应停止闪烁
5. 约839ms后，系统应自动复位，LED恢复闪烁

**预期结果**: ✅ 死循环触发后约0.8秒，系统自动复位

**⚠️ 测试完成后删除测试代码！**

---

### 测试3：复位原因检测测试

**目的**: 验证能正确识别看门狗复位

**步骤**:
1. 在 `Drv_Watchdog_Init()` 中添加LED指示：

```c
if(SysCtl_getWatchdogResetStatus())
{
    watchdog_reset_count++;
    SysCtl_clearWatchdogResetStatus();
    
    // 添加LED指示：快闪3次
    Uint16 i;
    for(i = 0; i < 3; i++)
    {
        GpioDataRegs.GPASET.bit.GPIO0 = 1;    // LED0亮
        DELAY_US(200000);                      // 延时200ms
        GpioDataRegs.GPACLEAR.bit.GPIO0 = 1;  // LED0灭
        DELAY_US(200000);
    }
}
```

2. 运行测试2的死循环测试
3. 观察复位后LED0是否快闪3次

**预期结果**: ✅ 看门狗复位后，LED0快闪3次，然后恢复正常闪烁

---

## 🔧 调试技巧

### 1. 查看喂狗统计

可以在调试器中查看私有变量：

```c
// 在 drv_watchdog.c 中
static Uint32 watchdog_reset_count = 0;     // 看门狗复位次数
static Uint32 watchdog_service_count = 0;   // 喂狗操作次数
```

**示例**:
- 运行1分钟后，`watchdog_service_count` 应约为 3000（50Hz × 60s）
- 如果发生过看门狗复位，`watchdog_reset_count` 会递增

---

### 2. 示波器测试

使用GPIO37作为测试引脚：

```c
void Drv_Watchdog_Service(void)
{
    GpioDataRegs.GPBTOGGLE.bit.GPIO37 = 1;  // 示波器观察
    
    watchdog_service_count++;
    SysCtl_serviceWatchdog();
}
```

**观察**: 应看到20ms周期的方波（50Hz）

---

## 📊 性能影响

| 指标 | 数值 | 说明 |
|------|------|------|
| **CPU占用** | < 0.01% | 每20ms执行一次，耗时<1us |
| **内存占用** | 8 字节 | 两个静态变量 |
| **代码大小** | ~200 字节 | 编译后的二进制大小 |
| **中断延迟** | 0 | 不在ISR中执行 |

---

## 🔧 实现细节

### 基于TI官方API

本驱动参考TI C2000Ware官方示例实现，使用标准的寄存器操作方式：

```c
// 喂狗函数（参考ServiceDog()）
void Drv_Watchdog_Service(void)
{
    EALLOW;
    WdRegs.WDKEY.bit.WDKEY = 0x0055;  // 第一步：写入0x55
    WdRegs.WDKEY.bit.WDKEY = 0x00AA;  // 第二步：写入0xAA
    EDIS;
}

// 配置看门狗（直接操作WDCR寄存器）
WdRegs.WDCR.all = 0x002E;  // 使能，64分频
```

### WDCR寄存器配置

```
WDCR = 0x002E = 0b00101110
  ↓
Bit 6   (WDDIS): 0 = 使能看门狗
Bit 5:3 (WDCHK): 101 = 校验位（固定）
Bit 2:0 (WDPS):  110 = 预分频64
```

---

## 📝 版本历史

| 版本 | 日期 | 变更内容 |
|------|------|----------|
| v1.1 | 2025-10-21 | 修复API，使用官方寄存器操作，编译成功 |
| v1.0 | 2025-10-21 | 初始版本，集成到3层架构 |

---

## 🔗 相关文档

- `ARCHITECTURE.txt` - 系统架构说明
- `Docs/PIN_MAPPING.md` - GPIO引脚分配
- `Framework/system_config.h` - 系统配置参数

---

## 📞 技术支持

如有问题，请参考：
- TI C2000 DriverLib 文档
- TMS320F28377D 技术参考手册（第18章：看门狗定时器）

